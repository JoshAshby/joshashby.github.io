---
title: '2024-01-08'
date: 2024-01-08
type: project-log
project: "/projects/anglerframe"
---

Hey wow, my first project log entry (ever on this site :O)!

I've spent an evening hour or so a day for the last week working on AnglerFrame and following along with the [fantastic tutorial](https://viewsourcecode.org/snaptoken/kilo) and have made it about halfway through "Chapter 4" which is the first chapter to really pick up the pace with the "text editor" bits. Up to this point (Chapters 1-3), we've been concerned with laying down the groundwork for building a UI using VT100 commands and doing tasks like moving the cursor around the screen and handling interacting with the terminal device in a clean fashion. Chapter 4 concerns itself with making a text viewer and really brings out the quirks in human language as we start to dive into handling displaying text and moving a cursor around it in a meaningful way.

At this point I've already implemented a few features that take a departure from the standard `kilo`, as well as having a fairly different take on the code layout. I've gotten UTF-8 displaying without issue thanks to Swift (although I'm sure I've got a few length bugs and other issues that'll surface as I work on "Chapter 5" which implements text-editing) and I've made the cursor behave more similar to Vim (more on this below) and I've got line numbers in a "gutter."

For example, here's AnglerFrame displaying [Markus Kuhn's UTF-8 plain text demo](https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-demo.txt):
![AnglerFrame Displaying a UTF-8 Sample File!](/assets/projects/anglerframe/2024-01-08-unicode.png)

In terms of code changes, I've made use of structs and classes in Swift to organize and further abstract some of the code away. At the moment, I've got an `Editor` class which is the heart of the system, integrating with a `Display` object which concerns itself with outputting things, and an `Input` object which concerns itself with converting raw input from `FileHandle.read(_:)` into a nicer enum. This should make it a little nicer to work on future expansions, such as: convert the `Input` code into an async system, where it'd write into a buffer that can be read from the main thread. It also feels a lot more "Swifty" to me and gets around some of the ugliness of C and its lack of name spacing and methods.
### Cursor Movement
The situation: You're moving vertically from a longer line to a shorter line, and the cursor is positioned in a column past the end of the shorter lines length.

Take, for example, the following lines:
- line 1: 5 columns
- line 2: 2 columns
- line 3: 10 columns

What happens to the cursor if you have it at column 4 on line 1, and move it to line 2? What happens when it moves from line 2 to line 3 after this?

In the original `kilo`, the cursor sets its position to the shorter lines length, effectively snapping it to a new position. In the above example, this moves the cursor from column 4 to column 2, and when you subsequently move from line 2 to line 3, the cursor remains in the new position of column 2. This is a little annoying because if you are trying to compare column positions and encounter a blank line, the cursor loses all context of where it originally was!

In Vim, however, the cursor is _displayed_ as snapping to the end of the shorter line but it retains its original column position when navigating. This means that in our example above, the cursor appears to snap back to column 2 on line 2, but will return to column 4 on line 3, keeping continuity a little better. When you insert text where the cursor is displayed at a different column from its remembered position, it resets to the currently displayed position. So if you move from column 4 on line 1 to line 2 and then insert a character, the new cursor's position will be column 3 after the insert, because it reset to column 2 on the insert and then moved over one column for the inserted character.

I've copied this behavior from Vim as I find it a lot more intuitive to how the cursor should move around text and even make use of the feature to find in correct indents, for example.
