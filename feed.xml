<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://joshisa.ninja/feed.xml" rel="self" type="application/atom+xml" /><link href="https://joshisa.ninja/" rel="alternate" type="text/html" /><updated>2023-12-21T01:17:35+00:00</updated><id>https://joshisa.ninja/feed.xml</id><title type="html">Ashby’s Hideout</title><subtitle>Sometimes I convert coffee into code. Rubber ducks are awesome.</subtitle><entry><title type="html">AoC 2022 Day 08 - The elves want a hidden treehouse with a great view, we’re their realtor</title><link href="https://joshisa.ninja/aoc/2022/12/08/AoC-2022-Day-08.html" rel="alternate" type="text/html" title="AoC 2022 Day 08 - The elves want a hidden treehouse with a great view, we’re their realtor" /><published>2022-12-08T23:59:00+00:00</published><updated>2022-12-08T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/08/AoC-2022-Day-08</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/08/AoC-2022-Day-08.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p>The elves, with us in tow, have come across a fantastic grove of trees and for whatever reason they think it’s a great place (and time to build a tree house). They’ve mapped out the tree heights and want to find the best point that’s hidden from the outside but still has a great view.</p>

<p>Today’s solution isn’t going to be the most efficient but I still had fun solving it and further cleaning up my solutions from the mess I made racing the clock. I’ve also grown more comfortable with the basics of the language, enough so that I feel that I can start stepping out and exploring more of the features available with firmer footing under me.</p>

<h2 id="parsing">Parsing</h2>

<p>As we’ve already seen, AoC has a number of different input formats and today’s is no different. We’ve got a 2-d array represented in text as a column per character and a row per line, each element is an integer within the range of 0-9. Compared to some other days, this is fairly trivial and a good format to get comfortable with as it’ll surely appear again in the future of either this year or the next.</p>

<p>If you recall, on day 1 we made heavy use of <code class="language-plaintext highlighter-rouge">split(separator:)</code> to break apart lines and on day 6 we used <code class="language-plaintext highlighter-rouge">Array(_: String)</code> to convert a string to an array where each element is a character in the string. There’s a further trick to reduce our work which is that Strings implement iterators that return a <code class="language-plaintext highlighter-rouge">String.Element</code>, aka a <code class="language-plaintext highlighter-rouge">Character</code>, each time, meaning we can directly call <code class="language-plaintext highlighter-rouge">map(_:)</code> on strings, neat! We can tie these together along with <code class="language-plaintext highlighter-rouge">Int(_: String) -&gt; Int?</code> to parse our input into a 2-d array that’s ready to go with minimal work, but we’ve got some snag. Firing up a REPL (<code class="language-plaintext highlighter-rouge">swift repl</code>) we see that there isn’t an <code class="language-plaintext highlighter-rouge">Int(_: Character)</code> initializer!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1&gt; Int(Character("1"))

  # whole bunch of messages like this:
  Swift.FixedWidthInteger:3:23: note: candidate expects value of type 'String' for parameter #1 (got 'Character')
</code></pre></div></div>

<p>Well, that’s inconvenient. We <em>could</em> convert the Character to a String and then initialize an Int but that’s just straight up messy. Looking through the docs for <code class="language-plaintext highlighter-rouge">Character</code> however we see that there’s a helpful <a href="https://developer.apple.com/documentation/swift/character/wholenumbervalue"><code class="language-plaintext highlighter-rouge">wholeNumberValue</code></a> property, perfect.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">TreeHeight</span> <span class="o">=</span> <span class="kt">Int</span>
<span class="kd">typealias</span> <span class="kt">TreeGridRow</span> <span class="o">=</span> <span class="p">[</span><span class="kt">TreeHeight</span><span class="p">]</span>
<span class="kd">typealias</span> <span class="kt">TreeHeightGrid</span> <span class="o">=</span> <span class="p">[</span><span class="kt">GridRow</span><span class="p">]</span>

<span class="k">let</span> <span class="nv">trees</span><span class="p">:</span> <span class="kt">TreeHeightGrid</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">line</span> <span class="k">in</span>
  <span class="n">line</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">char</span> <span class="k">in</span> <span class="n">char</span><span class="o">.</span><span class="n">wholeNumberValue</span><span class="o">!</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re okay with failing if the character doesn’t parse into an integer since that means our input is malformed and we don’t want to continue, so we’ll take the easy route of force-unwrapping it. Ideally we’d probably want to make a nice error message, however, to help reduce the time taken to track down where failures are.</p>

<p>To make our code a little more expressive, we also define a few <code class="language-plaintext highlighter-rouge">typealiases</code> to make it clear that <code class="language-plaintext highlighter-rouge">trees</code> is a 2-d array of our tree heights. This is a little contrived but it’s something that really helps me remember what a specific data structure is storing, beyond the plain <code class="language-plaintext highlighter-rouge">[[Int]]</code>.</p>

<h3 id="a-tangent">A Tangent</h3>

<p>Since we’re (or at least I am) getting more comfortable with the language, let’s try golfing this a tiny bit for fun and learn what we can!</p>

<p>I’ve glossed over these in previous days but Swift has implicitly args for its closures, called <a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID100">Shorthand Argument Names</a> which means that our <code class="language-plaintext highlighter-rouge">line.map(_:)</code> can turn into:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">trees</span><span class="p">:</span> <span class="kt">TreeGrid</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">line</span> <span class="k">in</span>
  <span class="n">line</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">wholeNumberValue</span><span class="o">!</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this case though, it’s not too clear what <code class="language-plaintext highlighter-rouge">$0</code> is immediately as we’re in a closure … wrapped in a closure. Not really ideal there, is it? I’m always on the fence about how much I like using shorthands in any language, since it does make the code a little harder to reason about so let’s keep digging.</p>

<p>As it turns out, we can get this even smaller. Swift also has <a href="https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID563">Key-Path Expressions</a> which allow us to reference a property or subscript on a value using a <code class="language-plaintext highlighter-rouge">\.&lt;name&gt;</code> pattern. In this case, swift knows that our <code class="language-plaintext highlighter-rouge">map(_:)</code> is getting called on a <code class="language-plaintext highlighter-rouge">Character</code> type so we can reference the <code class="language-plaintext highlighter-rouge">Character</code>’s <code class="language-plaintext highlighter-rouge">wholeNumberValue</code> property via <code class="language-plaintext highlighter-rouge">\.wholeNumberValue</code>. This will still return an optional, though, but thankfully the key-path support optional and force-unwrapping so our final parsing code can become:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">trees</span><span class="p">:</span> <span class="kt">TreeGrid</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">map</span><span class="p">(\</span><span class="o">.</span><span class="n">wholeNumberValue</span><span class="o">!</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>There are certainly more ways to golf this down further but I find this to be a good balance of extracting the data and being clean and seems like it’ll fit well with a lot of the AoC parsing problems if I go back and clean up old code!</p>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>Consider your map; how many trees are visible from outside the grid?</p>
</blockquote>

<p>So we’ve got our tree height map all parsed out into a fancy 2-d array and now we’ve got to find which trees the elves <em>shouldn’t</em> build in, because those trees are visible from outside the grove. We’ve got a couple of options here for how we go about checking if a tree is visible or hidden but we’ll do the easy route and just check each tree individually. To do this we need to:</p>

<ul>
  <li>Get our current tree’s height</li>
  <li>Get the trees above, below, left and right of our current tree</li>
  <li>Ensure that in all 4 directions there are trees equal to or greater in height than the current tree</li>
</ul>

<p>We’ll need a few things to make this easier to work with, firstly a typealias for coordinates which we’ll store as a named-element tuple:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">Coords</span> <span class="o">=</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
</code></pre></div></div>

<p>And next up a struct container for some helpful functions for interacting with our map:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">HeightMap</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">grid</span><span class="p">:</span> <span class="kt">TreeHeightGrid</span>

    <span class="k">let</span> <span class="nv">xBounds</span><span class="p">:</span> <span class="kt">Range</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">yBounds</span><span class="p">:</span> <span class="kt">Range</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">grid</span><span class="p">:</span> <span class="kt">TreeHeightGrid</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>

        <span class="k">self</span><span class="o">.</span><span class="n">xBounds</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">grid</span><span class="o">.</span><span class="n">first</span><span class="o">!.</span><span class="n">count</span>
        <span class="k">self</span><span class="o">.</span><span class="n">yBounds</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">grid</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">contains</span><span class="p">(</span><span class="n">_</span> <span class="nv">coords</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="n">xBounds</span> <span class="o">~=</span> <span class="n">coords</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">yBounds</span> <span class="o">~=</span> <span class="n">coords</span><span class="o">.</span><span class="n">y</span> <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">heightAt</span><span class="p">(</span><span class="n">_</span> <span class="nv">coords</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">TreeHeight</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nf">contains</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Coords </span><span class="se">\(</span><span class="n">coords</span><span class="se">)</span><span class="s"> are not within the maps coordinate space!"</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">coords</span><span class="o">.</span><span class="n">y</span><span class="p">][</span><span class="n">coords</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There’s a bit to break down here, we’re storing some bounds, and have a few helpers including one that gets the height of a tree if we have a set of coordinates.</p>

<p>When we initialize a new <code class="language-plaintext highlighter-rouge">HeightMap</code>, we’re also building two ranges which represent the bounds of our map. Using ranges here gets us two nice-to-haves: it’s easy to check if a coordinate calls within the map, and we can iterate over them to build lists of coordinates that are all within the map automatically. We’ll see this more in a minute.</p>

<p>Now, Ashby there’s a typo in <code class="language-plaintext highlighter-rouge">contains(_:)</code>, you might say. What’s this <code class="language-plaintext highlighter-rouge">~=</code> business? It’s actually a shortcut operator for <a href="https://developer.apple.com/documentation/swift/range/~=%28_:_:%29"><code class="language-plaintext highlighter-rouge">contains(_:)</code> that’s defined on <code class="language-plaintext highlighter-rouge">Range</code></a>! It’s not the most expressive but it does allow us to neatly condense our contains check for both dimensions into one line.</p>

<p>Finally, we’ve got a helper that does a bounds check before returning the height of the tree at a given set of coordinates. We’d probably want to make this a <code class="language-plaintext highlighter-rouge">func heightAt(_ coords: Coords) throws -&gt; TreeHeight</code> and have a specific <code class="language-plaintext highlighter-rouge">OutOfBounds</code> error rather than just fatally erroring out and exiting if this was production code, but we shouldn’t hit any failures during our normal puzzle operations so it’s more of a ‘we did our math wrong’ debugging helper.</p>

<p>We know that we’re going to need a list of coordinates for all of the trees, so how can we programmatically build that? We’ll use our ranges from the bounds! Because I want to also cut down on how many trees we have to iterate through, we’ll actually make an <code class="language-plaintext highlighter-rouge">interiorCoordinates</code> property on our <code class="language-plaintext highlighter-rouge">HeightMap</code> struct:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">interiorCoords</span><span class="p">:</span> <span class="p">[</span><span class="kt">Coords</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">yBounds</span><span class="o">.</span><span class="nf">dropFirst</span><span class="p">()</span><span class="o">.</span><span class="nf">dropLast</span><span class="p">()</span><span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">y</span> <span class="k">in</span>
        <span class="n">xBounds</span><span class="o">.</span><span class="nf">dropFirst</span><span class="p">()</span><span class="o">.</span><span class="nf">dropLast</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">x</span> <span class="nf">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">.dropFirst().dropLast()</code> jazz will remove the perimeter trees and what we get back Wil be an array of just the interior trees coordinates. With this in place, we can start working on our solution to part one:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">baseVisible</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">xBounds</span><span class="o">.</span><span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">yBounds</span><span class="o">.</span><span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span>

<span class="k">return</span> <span class="n">grid</span>
    <span class="o">.</span><span class="n">interiorCoords</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="n">baseVisible</span><span class="p">)</span> <span class="p">{</span> <span class="n">accumulator</span><span class="p">,</span> <span class="n">coords</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">currentHeight</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="nf">heightAt</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">let</span> <span class="nv">isHidden</span> <span class="o">=</span> <span class="c1">// ????</span>

        <span class="k">return</span> <span class="n">accumulator</span> <span class="o">+</span> <span class="p">(</span><span class="n">isHidden</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>We’ set up <code class="language-plaintext highlighter-rouge">baseVisible</code> using the count of all the trees along the perimeter as they’re already known to be visible. Because the 4 corners are included in both the xBounds and the yBounds ranges, however, we’ll over count the number of trees by 4, so we have to correct that.</p>

<p>Next, we reduce over the array of our interior coordinates, grab the height of the current tree and then decide if the tree is hidden or not. If it’s not hidden, we’ll add it to our accumulator.</p>

<p>Now things get fun. For each tree we need 4 arrays: trees above, below, left and right. Let’s work a little backwards here and start by scaffolding a <code class="language-plaintext highlighter-rouge">radiateOutFrom()</code> which will return these 4 arrays:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">radiateOutFrom</span><span class="p">(</span><span class="n">_</span> <span class="nv">coords</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Coords</span><span class="p">]]</span> <span class="p">{}</span>
</code></pre></div></div>

<p>And we can even fill in our <code class="language-plaintext highlighter-rouge">// ????</code> in our solution code too:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">isHidden</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="nf">radiateOutFrom</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">direction</span> <span class="k">in</span> <span class="n">direction</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">otherCoords</span> <span class="k">in</span> <span class="n">grid</span><span class="o">.</span><span class="nf">heightAt</span><span class="p">(</span><span class="n">otherCoords</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">otherHeights</span> <span class="k">in</span> <span class="n">otherHeights</span><span class="o">.</span><span class="n">firstIndex</span> <span class="p">{</span> <span class="n">height</span> <span class="k">in</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="n">currentHeight</span> <span class="p">}</span> <span class="p">}</span>
    <span class="o">.</span><span class="n">allSatisfy</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">}</span>
</code></pre></div></div>

<p>We’ll grab an array of arrays of coordinates, representing the 4 directions, map those coordinates to the height and then look to see if every direction has a tree which meets the requirements of being equal to or greater than the current tree’s height. If the current tree is taller than any of its peers in any direction than our <code class="language-plaintext highlighter-rouge">firstIndex(_:)</code> will return a nil and we’ll fail our <code class="language-plaintext highlighter-rouge">allSatisfy(_:)</code>).</p>

<p>Let us fill in the blanks with this <code class="language-plaintext highlighter-rouge">radiateOutFrom(_:)</code> and start by making a small helper. We want something that we can give a “direction” vector to and it’ll return the list of coordinates, without our origin, till the edge of the map:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">moveAwayFrom</span><span class="p">(</span><span class="n">from</span> <span class="nv">coords</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">,</span> <span class="nv">inDirection</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Coords</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">steps</span><span class="p">:</span> <span class="p">[</span><span class="kt">Coords</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">var</span> <span class="nv">currentStep</span> <span class="o">=</span> <span class="n">coords</span>
    <span class="k">var</span> <span class="nv">nextStep</span><span class="p">:</span> <span class="kt">Coords</span> <span class="o">=</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">currentStep</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">inDirection</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">currentStep</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">inDirection</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">while</span> <span class="nf">contains</span><span class="p">(</span><span class="n">nextStep</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">currentStep</span> <span class="o">=</span> <span class="n">nextStep</span>
        <span class="n">nextStep</span> <span class="o">=</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">currentStep</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">inDirection</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">currentStep</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">inDirection</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">steps</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">currentStep</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">steps</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You could probably muck with <code class="language-plaintext highlighter-rouge">stride()</code> or <code class="language-plaintext highlighter-rouge">zip</code> here to make this a little more condensed, but the general gist is that we’ll add our direction vector to our coordinates, appending the new set of coordinates to a list for as long as we’re still on the map. Once an edge is hit, we’ll include the edge and then return the full array of coordinates.</p>

<p>With that, we just need to provide a “direction” vector for each of the directions, map over them and return the results:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">radiateOutFrom</span><span class="p">(</span><span class="n">_</span> <span class="nv">coords</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Coords</span><span class="p">]]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">]</span>
        <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">direction</span> <span class="k">in</span> <span class="nf">moveAwayFrom</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">coords</span><span class="p">,</span> <span class="nv">inDirection</span><span class="p">:</span> <span class="n">direction</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that, our solution to part one should be done!</p>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>Consider each tree on your map. What is the highest scenic score possible for any tree?</p>
</blockquote>

<p>Naturally being well hidden shouldn’t preclude the tree house from having a great view. We’ll have to again iterate through the interior trees and this time, calculate the view score which consists of the distance to the first tree that is of equal or greater height all multiplied together for each direction. After we’ve done this, we’ll need to find the highest-ranking view score.</p>

<p>Our initial setup for the solution starts off the same as before, we iterate over the interior coordinates and then get our list of tree heights in the 4 directions. The only difference is that we’ll take the first index of the tree matching our criteria OR the total number of trees in that direction, ie the count of the directions array:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">grid</span>
    <span class="o">.</span><span class="n">interiorCoords</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">coords</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">currentHeight</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="nf">heightAt</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="nf">radiateOutFrom</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">direction</span> <span class="k">in</span> <span class="n">direction</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">otherCoords</span> <span class="k">in</span> <span class="n">grid</span><span class="o">.</span><span class="nf">heightAt</span><span class="p">(</span><span class="n">otherCoords</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">otherHeights</span> <span class="k">in</span>
                <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">otherHeights</span><span class="o">.</span><span class="n">firstIndex</span> <span class="p">{</span> <span class="n">height</span> <span class="k">in</span> <span class="n">height</span> <span class="o">&gt;=</span> <span class="n">currentHeight</span> <span class="p">}?</span><span class="o">.</span><span class="nf">advance</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">index</span> <span class="p">??</span> <span class="n">otherHeights</span><span class="o">.</span><span class="n">count</span>
            <span class="p">}</span>
            <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">max</span><span class="p">()</span> <span class="p">??</span> <span class="mi">0</span>
</code></pre></div></div>

<p>There’s one little trick in here, that <code class="language-plaintext highlighter-rouge">advance(by: 1)</code> which is the same as <code class="language-plaintext highlighter-rouge">index + 1</code> but has the advantage of being optionally chainable. We’re doing this because, as we’ve seen the week before, we have to convert our 0-indexed problem space into a 1-indexed solution space for the puzzle to correctly validate.</p>

<p>And that’s it!</p>

<p>There’s some additional clean up that you could do. For example, I consolidated the index/advance/nil-coalescing into my <code class="language-plaintext highlighter-rouge">radiateOutFrom</code> function such that it’s signature looks like:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">radiateOutFrom</span><span class="p">(</span><span class="n">_</span> <span class="nv">coords</span><span class="p">:</span> <span class="kt">Coords</span><span class="p">,</span> <span class="nv">tallerThan</span><span class="p">:</span> <span class="kt">TreeHeight</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)]</span>
</code></pre></div></div>

<p>I’ll leave it as an exercise for the reader to figure out what other changes need to be made for each solution and whether or not this is a cleaner approach.</p>

<p>Until tomorrow!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/07/AoC-2022-Day-07.html">Day 07</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 07 - The elves give you an outdated device with not enough disk space, we delete the filesystem</title><link href="https://joshisa.ninja/aoc/2022/12/07/AoC-2022-Day-07.html" rel="alternate" type="text/html" title="AoC 2022 Day 07 - The elves give you an outdated device with not enough disk space, we delete the filesystem" /><published>2022-12-07T23:59:00+00:00</published><updated>2022-12-07T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/07/AoC-2022-Day-07</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/07/AoC-2022-Day-07.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p>Welcome back to day number 7 of the 2022 Advent of Code, we’ll have worked our way through a whole week of challenges after finishing today’s puzzle!</p>

<p>Continuing with our theme of trying to write not over engineered, but also not terribly unclear “clever” code, we’ll be parsing the input into an actual tree structure. This’ll also give us a taste of using classes and protocols and give us some practice with working with types!</p>

<h2 id="parsing">Parsing</h2>

<p>Parsing today’s input isn’t as funky as day 5 was, but it’s still more involved than previous days where we could get away with a few splits and a map.</p>

<p>Per the usual, let’s build out the base containers for our tree. We’ve got both files and directories to represent and we know that directories have some children and a parent, while files are just a size and pathname. Technically, to solve the problem we only need to store the sizes and could represent this as a single type, but for the sake of making debugging easier, I’ve chosen to split directories and files apart and to store extra information such as the path.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Directory</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// TODO: Implement this</span>

    <span class="k">let</span> <span class="nv">parent</span><span class="p">:</span> <span class="kt">Directory</span><span class="p">?</span>
    <span class="k">var</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// TODO: We'll need to figure out what this is</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">parent</span><span class="p">:</span> <span class="kt">Directory</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">File</span><span class="p">:</span> <span class="kt">Node</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have two problems, as our little <code class="language-plaintext highlighter-rouge">// TODO</code> comment’s points out. The first is that we need a way to calculate the size of a directory, and the second is that <code class="language-plaintext highlighter-rouge">children</code> can be <em>both</em> directories <strong>and</strong> files so how do we make an array that can hold both? We need to know how to store the children before we can worry about finding the size of a directory so let’s focus on that for now.</p>

<p>In order to store both files and directories in <code class="language-plaintext highlighter-rouge">children</code> we’ll need to have a common base that they both implement. We have two options here, we could either use a type union, or we could use a protocol. In swift, the equivalent of a type union is created using an <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html#ID148">enum</a> with an associated value, like so:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Node</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">directory</span><span class="p">(</span><span class="kt">Directory</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">file</span><span class="p">(</span><span class="kt">File</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">.</span><span class="nf">directory</span><span class="p">(</span><span class="kt">Directory</span><span class="p">(</span><span class="s">"a"</span><span class="p">)),</span>
    <span class="o">.</span><span class="nf">file</span><span class="p">(</span><span class="kt">File</span><span class="p">(</span><span class="s">"b.txt"</span><span class="p">,</span> <span class="mi">14848514</span><span class="p">))</span>
<span class="p">]</span>
</code></pre></div></div>

<p>This’ll work dandy, but it duplicates information that is already encoded in the type of object: A directory is a directory and a file is a file.</p>

<p>We can do better with protocols and even gain some functionality while we’re at it. A protocol in swift is typically called an “interface” in other languages. It’s basically a way to tell swift “these two, separate types implement this subset of functionality, so I can use them interchangeably” and it looks a bit like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Node</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">path</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Update these definitions to state that Directory and File implement our new protocol:</span>
<span class="kd">class</span> <span class="kt">Directory</span><span class="p">:</span> <span class="kt">Node</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">// Same as before</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">File</span><span class="p">:</span> <span class="kt">Node</span> <span class="p">{</span>
    <span class="c1">// Same as before</span>
<span class="p">}</span>

<span class="c1">// Now we can do this:</span>
<span class="k">var</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="kt">Directory</span><span class="p">(</span><span class="s">"a"</span><span class="p">),</span>
    <span class="kt">File</span><span class="p">(</span><span class="s">"b.txt"</span><span class="p">,</span> <span class="mi">14848514</span><span class="p">)</span>
<span class="p">]</span>
</code></pre></div></div>

<p>That’s not too different from the enum setup above, but now we don’t have to worry about duplicating information that is intrinsic to our system already. Using the protocol also lets us store both directories and files in our <code class="language-plaintext highlighter-rouge">children</code> array but it has an added benefit: we can specify functions and properties that all <code class="language-plaintext highlighter-rouge">Node</code>s should implement and can call them without having to worry about any type casting. For example, to get an Array of the sizes of each child we can just map over them and call the protocols <code class="language-plaintext highlighter-rouge">.size</code> property:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">children</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$1</span><span class="o">.</span><span class="n">size</span> <span class="p">}</span>
</code></pre></div></div>

<p>Now that we’ve got our base containers set up, let’s get into parsing our input into our tree structure. Scanning through our input, we find 4 different formats:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$ cd /</code> moves us up and down the tree</li>
  <li><code class="language-plaintext highlighter-rouge">$ ls</code> marks the start of several lines denoting the current node’s contents</li>
  <li><code class="language-plaintext highlighter-rouge">dir a</code> tells us that there is a directory <code class="language-plaintext highlighter-rouge">a</code> we need to add to our children array</li>
  <li><code class="language-plaintext highlighter-rouge">14848514 b.txt</code> tells us that there is a file <code class="language-plaintext highlighter-rouge">b.txt</code> we need to add to our children array</li>
</ul>

<p>We can actually ignore <code class="language-plaintext highlighter-rouge">$ ls</code> lines completely since they’re just a marker in our input saying, “the next lines are a listing for the directory we just moved into.”</p>

<p>We can also ignore the first <code class="language-plaintext highlighter-rouge">$ cd /</code> since it’s telling us that we’re starting at the top, the root of the tree. We’ll take into account when we set up our parser which will remove the need to handle creating a root when we come across <code class="language-plaintext highlighter-rouge">$ cd /</code>, further simplifying the cases we need to deal with.</p>

<p>Swift’s iterator helpers makes it easy to ignore both the <code class="language-plaintext highlighter-rouge">$ ls</code> lines, and our first line (<code class="language-plaintext highlighter-rouge">$ cd /</code>) with <code class="language-plaintext highlighter-rouge">dropFirst()</code> and <code class="language-plaintext highlighter-rouge">filter(where:)</code>. After that we just have to parse each line to build up our tree:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">currentParent</span> <span class="o">=</span> <span class="kt">Directory</span><span class="p">(</span><span class="s">"/"</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">parseString</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Directory</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">root</span> <span class="o">=</span> <span class="n">currentParent</span>

    <span class="k">var</span> <span class="nv">lines</span> <span class="o">=</span> <span class="n">input</span>
        <span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">dropFirst</span><span class="p">()</span>
        <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">!=</span> <span class="s">"$ ls"</span> <span class="p">}</span>
        <span class="o">.</span><span class="nf">forEach</span><span class="p">(</span><span class="n">parseLine</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>We’ll use <code class="language-plaintext highlighter-rouge">currentParent</code> to handle inserting nodes into the correct child array and we’ll use <code class="language-plaintext highlighter-rouge">$ cd &lt;path&gt;</code> to change it. Since we want to operate on the root of the tree once we get to solving the challenge, I’ve kept a reference to the root node for convenience which lets us freely change where <code class="language-plaintext highlighter-rouge">currentParent</code> is pointing at.</p>

<p>With this we’ve narrowed our cases down to three and we can further investigate them for a pattern that’ll make it easy to determine which case each line falls into. If we split each line on spaces, we’ll get the following:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$ cd a</code> can be split into <code class="language-plaintext highlighter-rouge">["$", "cd", "a"]</code></li>
  <li><code class="language-plaintext highlighter-rouge">dir a</code> can be split into <code class="language-plaintext highlighter-rouge">["dir", "a"]</code></li>
  <li><code class="language-plaintext highlighter-rouge">14848514 b.txt</code> can be split into <code class="language-plaintext highlighter-rouge">["14848514", "b.txt"]</code></li>
</ul>

<p>In other words our pattern is:</p>

<ul>
  <li>If the line starts with <code class="language-plaintext highlighter-rouge">$</code> it’s a cd command and the third index is our directory to change into</li>
  <li>If the line starts with <code class="language-plaintext highlighter-rouge">dir</code> it’s a new directory command and the second index is the directory name</li>
  <li>Otherwise it’s a new file command where the first index is the size and the second is file name</li>
</ul>

<p>There’s one wrinkle we’ll have to address for <code class="language-plaintext highlighter-rouge">cd</code> commands specifically: <code class="language-plaintext highlighter-rouge">$ cd ..</code>. This means we’ll need to navigate to the current directory’s parent, not a child directory.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">parts</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>

    <span class="k">switch</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">"$"</span><span class="p">:</span>
            <span class="k">let</span> <span class="nv">dir</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">dir</span> <span class="o">==</span> <span class="s">".."</span> <span class="p">{</span>
                <span class="n">currentParent</span> <span class="o">=</span> <span class="n">currentParent</span><span class="o">.</span><span class="n">parent</span><span class="o">!</span>
                <span class="k">return</span>
            <span class="p">}</span>

            <span class="k">guard</span> <span class="k">let</span> <span class="nv">newParent</span> <span class="o">=</span> <span class="n">currentParent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="nf">first</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">dir</span> <span class="p">})</span> <span class="k">as?</span> <span class="kt">Directory</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Can't find a directory for path </span><span class="se">\(</span><span class="n">dir</span><span class="se">)</span><span class="s"> in </span><span class="se">\(</span><span class="n">currentParent</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="n">currentParent</span> <span class="o">=</span> <span class="n">newParent</span>

        <span class="k">case</span> <span class="s">"dir"</span><span class="p">:</span>
            <span class="k">let</span> <span class="nv">dir</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">let</span> <span class="nv">newDirectory</span> <span class="o">=</span> <span class="kt">Directory</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="nv">parent</span><span class="p">:</span> <span class="n">currentParent</span><span class="p">)</span>
            <span class="n">currentParent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">newDirectory</span><span class="p">)</span>

        <span class="k">default</span><span class="p">:</span>
            <span class="k">let</span> <span class="nv">path</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">??</span> <span class="mi">0</span>

            <span class="k">let</span> <span class="nv">newFile</span> <span class="o">=</span> <span class="kt">File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">currentParent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">newFile</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we get our first taste of guard statements this season as well:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">newParent</span> <span class="o">=</span> <span class="n">currentParent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="nf">first</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">dir</span> <span class="p">})</span> <span class="k">as?</span> <span class="kt">Directory</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Can't find a directory for path </span><span class="se">\(</span><span class="n">dir</span><span class="se">)</span><span class="s"> in </span><span class="se">\(</span><span class="n">currentParent</span><span class="o">.</span><span class="n">path</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is essentially a smart <code class="language-plaintext highlighter-rouge">if</code> statement that lets swift set the guarantee for any code after the <code class="language-plaintext highlighter-rouge">guard</code> that <code class="language-plaintext highlighter-rouge">newParent</code> will exist and be a <code class="language-plaintext highlighter-rouge">Directory</code>. Typically guard statements are a better way to go than the forced optional-unwrapping and forced casting that we’ve done on previous days but since we suspect that no file will be named the same as a directory and thus causing some issues, we could in theory shorten this to:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">newParent</span> <span class="o">=</span> <span class="n">currentParent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="nf">first</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">dir</span> <span class="p">})</span><span class="o">!</span> <span class="k">as!</span> <span class="kt">Directory</span>
</code></pre></div></div>

<p>But those two <code class="language-plaintext highlighter-rouge">!</code> forces make the code a bit uglier and are a smell to me.</p>

<p>There are a few other optional related gotchas: we’re assuming that we’ll never try to navigate to the roots parent, which would be nil and we could in theory get a file of size <code class="language-plaintext highlighter-rouge">0</code> if the int parsing fails. Both of those are fair assumptions we can make, however, since we know the format “shouldn’t” have either of those issues.</p>

<p>Finally we’ve got our input parsed into a tree structure and we can focus on solving this!</p>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>Find all of the directories with a total size of at most 100000. What is the sum of the total sizes of those directories?</p>
</blockquote>

<p>In order to solve this, for each directory in our tree we need to get an array consisting of that directory’s size as well as the size of all the child directories. We’ll want to combine all of these into a single array which we can filter down to all sizes equal to or less than 100000 before finally summing them together. In order to do this, we’ll need to finish our calculation for the size of a directory first. Remember how we’ve got a computed property setup in our <code class="language-plaintext highlighter-rouge">Directory</code>?</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// TODO: Implement this</span>
</code></pre></div></div>

<p>This is where having <code class="language-plaintext highlighter-rouge">size</code> on the protocol, and having all our children using this protocol comes in handy. To get the size of a directory it’s simply a summation of all the sizes of its children:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="n">children</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nv">$1</span><span class="o">.</span><span class="n">size</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>Next up we need to build an array of directory sizes. We’ll use some swift pattern matching, specifically a <code class="language-plaintext highlighter-rouge">for in where</code> statement to iterate through our children array and only pull out the directories. I attached this function as an instance function for a <code class="language-plaintext highlighter-rouge">Directory</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Directory</span><span class="p">:</span> <span class="kt">Node</span> <span class="p">{</span>
    <span class="c1">// Existing code ...</span>

    <span class="kd">func</span> <span class="nf">subSizes</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">sizes</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">size</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="k">where</span> <span class="n">child</span> <span class="k">is</span> <span class="kt">Directory</span> <span class="p">{</span>
            <span class="c1">// we can safely force cast this since we filtered</span>
            <span class="c1">// it down to directories in the where clause above</span>
            <span class="k">let</span> <span class="nv">child</span> <span class="o">=</span> <span class="n">child</span> <span class="k">as!</span> <span class="kt">Directory</span>

            <span class="n">sizes</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">contentsOf</span><span class="p">:</span> <span class="n">child</span><span class="o">.</span><span class="nf">subSizes</span><span class="p">())</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">sizes</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For every directory we’ll take its size and append the sizes, we get back from all of the children directories. For example, if we’ve got a tree that looks like this, where the sizes are in parentheses:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- / (13)
  - a/ (2)
    - b.txt (2)
  - e/ (11)
    - f/ (11)
      - dodge.coin (6)
      - hat.trick (5)
</code></pre></div></div>

<ul>
  <li>We’ll start at <code class="language-plaintext highlighter-rouge">/</code> and <code class="language-plaintext highlighter-rouge">sizes</code> will be <code class="language-plaintext highlighter-rouge">[13]</code>.</li>
  <li>Next we’ll loop over the child directories, so we’ll visit <code class="language-plaintext highlighter-rouge">a</code> first which will give us back <code class="language-plaintext highlighter-rouge">[2]</code> since <code class="language-plaintext highlighter-rouge">a</code> only has a single file with size <code class="language-plaintext highlighter-rouge">2</code> in it</li>
  <li>We’ll continue at the end of our for-loop and we’ll append the contents of <code class="language-plaintext highlighter-rouge">a</code>’s <code class="language-plaintext highlighter-rouge">[2]</code> to our existing <code class="language-plaintext highlighter-rouge">[13]</code> in the root for <code class="language-plaintext highlighter-rouge">[13, 2]</code></li>
  <li>Then we’ll visit <code class="language-plaintext highlighter-rouge">e</code> which takes us down into <code class="language-plaintext highlighter-rouge">f</code></li>
  <li>in <code class="language-plaintext highlighter-rouge">f</code> we’ll get <code class="language-plaintext highlighter-rouge">[11]</code></li>
  <li>returning back to <code class="language-plaintext highlighter-rouge">e</code>, we’ll have the equivelent of <code class="language-plaintext highlighter-rouge">[11].append(contentsOf: [11])</code></li>
  <li>finally back to the root where we have <code class="language-plaintext highlighter-rouge">[13, 2].append(contentsOf: [11, 11])</code></li>
</ul>

<p>For a little more of a visual aid, this shows the nesting we’ll see while traversing from the root into <code class="language-plaintext highlighter-rouge">f/</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌────────────────────────────────────────────────┐
│              ┌─────────────────────────────┐   │
│              │            ┌────────────┐   │   │
│ / - [ 13, 2, │ e/ - [ 11, │ f/ - [11]  │ ] │ ] │
│              │            └────────────┘   │   │
│              └─────────────────────────────┘   │
└────────────────────────────────────────────────┘
</code></pre></div></div>

<p>Since we’re using <code class="language-plaintext highlighter-rouge">append(contentsOf:)</code>, which is implicitly flattening our arrays as we go, our final array that <code class="language-plaintext highlighter-rouge">root.subSizes()</code> returns is:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
</code></pre></div></div>

<p>From here we can do a filter where the element is less than or equal to 100000 and finally sum it up for our part on solution:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">root</span><span class="o">.</span><span class="nf">subSizes</span><span class="p">()</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>Find the smallest directory that, if deleted, would free up enough space on the file system to run the update. What is the total size of that directory?</p>
</blockquote>

<p>We’ve got to first find out the minimum size of directory that we need to delete. We’ll start with finding how much space we have free which is the total space we have on the disk, <code class="language-plaintext highlighter-rouge">70000000</code> minus the size of our root directory. Then we find the amount of extra space required for the update, ie: the minimum amount of space we need to delete by taking the update size and subtracting the existing free space that we can use.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">totalSpace</span> <span class="o">=</span> <span class="mi">70000000</span>

<span class="k">let</span> <span class="nv">usedSpace</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">size</span>
<span class="k">let</span> <span class="nv">freeSpace</span> <span class="o">=</span> <span class="n">totalSpace</span> <span class="o">-</span> <span class="n">usedSpace</span>

<span class="k">let</span> <span class="nv">requiredSpace</span> <span class="o">=</span> <span class="mi">30000000</span> <span class="o">-</span> <span class="n">freeSpace</span>
</code></pre></div></div>

<p>This gives us the number we need to filter our directories down with: any directory size equal to or more than the required space is a candidate for deletion. From that filtered down list of directory sizes, we’ll take the minimum and will have our solution:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">root</span><span class="o">.</span><span class="nf">subSizes</span><span class="p">()</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="n">requiredSpace</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">min</span><span class="p">()</span> <span class="p">??</span> <span class="mi">0</span>
</code></pre></div></div>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/08/AoC-2022-Day-08.html">Day 08</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/06/AoC-2022-Day-06.html">Day 06</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 06 - The elves recieve an email, we decode it</title><link href="https://joshisa.ninja/aoc/2022/12/06/AoC-2022-Day-06.html" rel="alternate" type="text/html" title="AoC 2022 Day 06 - The elves recieve an email, we decode it" /><published>2022-12-06T23:59:00+00:00</published><updated>2022-12-06T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/06/AoC-2022-Day-06</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/06/AoC-2022-Day-06.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>How many characters need to be processed before the first start-of-packet marker is detected?</p>
</blockquote>

<p>Today we need to run a sliding window over an array of bytes in order to find a “start-of-packet” marker, or a set of 4 consecutive bytes that are all unique within that window. My original solution used a ring buffer, sometimes also referred to as a circular buffer, which is essentially an array of a fixed length that’ll remove an element from the front when you push onto it, if its length is over the length after the push operation.</p>

<p>We can simplify the process, however, and instead just keep track of the upper and lower-bound indices of our window, taking a slice from the input between those bounds and checking for 4 unique characters</p>

<p>For example, using <code class="language-plaintext highlighter-rouge">mjqjpqmgbljsphdztnvjfqwrcgsmlb</code> we can start off with the first 4 characters:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[mjqj] pqmgbljsphdztnvjfqwrcgsmlb
</code></pre></div></div>

<p>This isn’t the start-of-packet as there are only 3 unique characters since <code class="language-plaintext highlighter-rouge">j</code> is repeated twice. Sliding our window forward by one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m [jqjp] qmgbljsphdztnvjfqwrcgsmlb
</code></pre></div></div>

<p>This is not the packet, so we continue on with sliding the window forward by one, two more iterations:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mj [qjpq] mgbljsphdztnvjfqwrcgsmlb
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mjq [jpqm] gbljsphdztnvjfqwrcgsmlb
</code></pre></div></div>

<p>Finally we’ve got a window where there are 4 distinct characters present, our start-of-message packet! We’ll return the index of the upper bound of the window as our solution, in this case 7.</p>

<p>Now that we’ve got that figured out, we need to get an array of characters out of our input. Thankfully, swift gives us an <code class="language-plaintext highlighter-rouge">Array(_ str: String)</code> initializer:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Character</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Array</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now we just have to create that sliding window. We’ll define the window size:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">windowSize</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">let</span> <span class="nv">adjustedWindowSize</span> <span class="o">=</span> <span class="n">windowSize</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>We have to make a small adjustment to make the window size usable within our arrays. If we were to do <code class="language-plaintext highlighter-rouge">line[0...4]</code> we’d actually get the first <strong>5</strong> characters instead of the first four that we need to start off with, as a result of the array being 0-indexed but our counting being 1-indexed. As a result we subtract one from our 1-indexed count in order to get a 0-indexed window.</p>

<p>Now we just iterate from our window size up to the line’s length. This’ll give us the upper-bound shifted forward by 1 each iteration, and we can compute the new lower-bound by subtracting our window size to get the slice of 4 characters within those bounds:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">upperBound</span> <span class="k">in</span> <span class="n">adjustedWindowSize</span><span class="o">..&lt;</span><span class="n">line</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">lowerBound</span> <span class="o">=</span> <span class="n">upperBound</span> <span class="o">-</span> <span class="n">adjustedWindowSize</span>

    <span class="k">if</span> <span class="kt">Set</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">lowerBound</span><span class="o">...</span><span class="n">upperBound</span><span class="p">])</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="n">windowSize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">upperBound</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, we convert the slice into a <code class="language-plaintext highlighter-rouge">Set</code> to get the unique characters and take the count. If it’s 4, we can return our upper bound but we have to remember to convert it back to a 1-indexed bound for the answer!</p>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>How many characters need to be processed before the first start-of-message marker is detected?</p>
</blockquote>

<p>Now we’re looking for a second packet but the technique is the same, we need a sliding window of 14 characters over the input to find the first instance where the 14 characters are all distinct. Thankfully, since we’ve defined the window size as a standalone variable we can just adjust it from 4 up to 14 and that’s it!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/07/AoC-2022-Day-07.html">Day 07</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/05/AoC-2022-Day-05.html">Day 05</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 05 - The elves rearrange some crates on a boat, we play alphabet blocks with the crates</title><link href="https://joshisa.ninja/aoc/2022/12/05/AoC-2022-Day-05.html" rel="alternate" type="text/html" title="AoC 2022 Day 05 - The elves rearrange some crates on a boat, we play alphabet blocks with the crates" /><published>2022-12-05T23:59:00+00:00</published><updated>2022-12-05T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/05/AoC-2022-Day-05</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/05/AoC-2022-Day-05.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p>Today’s problem turned out to be more of a parsing problem than a logic problem for me. Last year when doing AoC in OCaml, I wrote my own parser combinator library and I’m heavily considering doing the same in swift just to learn how to better, but even then a parser combinator wouldn’t have helped me nearly as much as I would have liked.</p>

<h2 id="parsing">Parsing</h2>

<p>Our input consists of three bits of information:</p>
<ul>
  <li>the crates and which stack they are in</li>
  <li>the stacks number</li>
  <li>the operations to move crates from one stack to another</li>
</ul>

<p>The first two are separated from the moves via a double line break and thankfully the moves are fairly easy to break away. The stacks, however, are going to take a bit more work:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [D]
[N] [C]
[Z] [M] [P]
 1   2   3
</code></pre></div></div>

<p>One thing to note is that each stack’s columns are 4 characters wide (with the exception of the last which is 3) so we could reuse our <code class="language-plaintext highlighter-rouge">Array#chunked()</code> extension from day 04 to get our stacks broken apart.</p>

<table>
  <thead>
    <tr>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[</td>
      <td>D</td>
      <td>]</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Note that we’ll want to use the safer version that slices to the chunk size OR the string length if it’s smaller to account for the last stack being of length 3 and not 4. Per chunk we can extract the second element to figure out if it’s a stack or empty space, something like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">rawStacks</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">stackDefinitions</span> <span class="o">=</span> <span class="n">rawStacks</span><span class="o">.</span><span class="nf">dropLast</span><span class="p">()</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">line</span> <span class="k">in</span>
        <span class="kt">Array</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="nf">chunked</span><span class="p">(</span><span class="nv">into</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">reversed</span><span class="p">()</span>
</code></pre></div></div>

<p>There’s a lot going on here, first we don’t care about the last line as it’s just the stack numbers so we call <code class="language-plaintext highlighter-rouge">Array#dropLast()</code> which will give us a collection that, when iterated over, will not include the final line. It’s a cleaner way of doing:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rawStacks</span><span class="p">[</span><span class="mi">0</span><span class="o">..&lt;</span><span class="n">rawStacks</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Next, for each line we convert it to an array of <code class="language-plaintext highlighter-rouge">String.Element</code>s aka <code class="language-plaintext highlighter-rouge">Character</code>s and use our chunking function to get each stack broken apart. Finally we map over the array of chunks to give us back an array where each index corresponds to a stack and each element with either be an empty space or a crate letter. Finally, we reverse it which will make the next step of transposing these rows into our initial stacks array a lot easier. After running over our lines, we end up with a 2-d array looking something like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="s">"Z"</span><span class="p">,</span> <span class="s">"M"</span><span class="p">,</span> <span class="s">"P"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"N"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">" "</span><span class="p">],</span>
  <span class="p">[</span><span class="s">" "</span><span class="p">,</span> <span class="s">"D"</span><span class="p">,</span> <span class="s">" "</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Lastly, before we move onto parsing the moves and solving part one, we need to transpose our stack data such that we end up with an array where each index is a column or stack, as opposed to the current situation that we have, where each index is a row. Our final array that we’ll use for the solutions will look like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="s">"Z"</span><span class="p">,</span> <span class="s">"N"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"M"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"D"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"P"</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>First, we’ll need to make the array representing our stacks that we’re going to transpose into. It’ll be easier if we pre-fill it with empty arrays so that we can just append to the correct stack when we come across a crate, so we can use the <code class="language-plaintext highlighter-rouge">Array(repeating:, count:)</code> initializer and we’ll use the length of our first row as a quick a dirty count for the number of stacks that we have:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numberOfStacks</span> <span class="o">=</span> <span class="n">stackDefinitions</span><span class="o">.</span><span class="n">first</span><span class="o">!.</span><span class="n">count</span>
<span class="k">var</span> <span class="nv">stacks</span><span class="p">:</span> <span class="p">[[</span><span class="kt">Character</span><span class="p">]]</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="p">[],</span> <span class="nv">count</span><span class="p">:</span> <span class="n">numberOfStacks</span><span class="p">)</span>
</code></pre></div></div>

<p>If number of crates is <code class="language-plaintext highlighter-rouge">3</code> for example, this is equivalent to:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">stacks</span><span class="p">:</span> <span class="p">[[</span><span class="kt">Character</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span> <span class="p">]</span>
</code></pre></div></div>

<p>But it avoids hardcoding the length in, which is helpful when we want this code to run against both the example input and our own input file. Another approach would be to simply map over the first row, returning an empty array:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">stacks</span><span class="p">:</span> <span class="p">[[</span><span class="kt">Character</span><span class="p">]]</span> <span class="o">=</span> <span class="n">stackDefinitions</span><span class="o">.</span><span class="n">first</span><span class="o">!.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="p">[]</span> <span class="p">}</span>
</code></pre></div></div>

<p>However, I wanted to show off the use of the Array initializer, and I think it’s a littler clearer than the map.</p>

<p>Finally we can transpose our data. For each row we’ll iterate over the elements and use the elements index to look up which stack array we need. We’ll also filter out spaces using swift’s <code class="language-plaintext highlighter-rouge">for ... where</code> syntax:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">stackRow</span> <span class="k">in</span> <span class="n">stackDefinitions</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">crate</span><span class="p">)</span> <span class="k">in</span> <span class="n">stackRow</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="k">where</span> <span class="n">crate</span> <span class="o">!=</span> <span class="s">" "</span> <span class="p">{</span>
        <span class="n">stacks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">crate</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally we’ve gotten our stack data parsed out and we’re onto the moves instructions before we solve this. Thankfully parsing the move is easier than the stack definitions.</p>

<p>First we’ll define a little container to make our code a little easier to read:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Move</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">numberOfCrates</span><span class="p">:</span> <span class="kt">Int</span>

    <span class="k">let</span> <span class="nv">fromStackIndex</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">toStackIndex</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since the move instructions are all in the same fixed format, we can do a little trick rather than reach for something like regex (what I did when I initially solved this):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">&gt;</span> <span class="s">"move 3 from 5 to 2"</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
<span class="err">$</span><span class="kt">R0</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span> <span class="n">values</span> <span class="p">{</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"move"</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"3"</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"from"</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">"5"</span>
  <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"to"</span>
  <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">"2"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For each line we can split on the spaces and take:</p>
<ul>
  <li>the second element as our number of crates</li>
  <li>the fourth element as the stack to move the crates <em>from</em></li>
  <li>the sixth element as the stack to move the creates <em>to</em></li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">parseMoveLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Move</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">numberOfCrates</span><span class="p">:</span> <span class="kt">Int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">!</span><span class="p">,</span>
        <span class="nv">fromStackIndex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">!</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nv">toStackIndex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">!</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The key part here is to subtract one from the stack numbers as the puzzle uses 1-indexing but our code operates in swift’s 0-indexing system.</p>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>After the rearrangement procedure completes, what crate ends up on top of each stack?</p>
</blockquote>

<p>At this point we’ve got our stacks, modeled as an <code class="language-plaintext highlighter-rouge">[[Character]]</code> and our move instructions in an <code class="language-plaintext highlighter-rouge">[Move]</code>. For each move, we’ve got an amount of crates to transfer from one stack to another stack and this happens sequentially. For example, the line <code class="language-plaintext highlighter-rouge">move 3 from 1 to 3</code> requires us to <em>pop</em> a crate off of stack number 1 and <em>append</em> it to stack number 3, and we’ll do that three times.</p>

<p>Using the example, we start with the following stacks:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="s">"Z"</span><span class="p">,</span> <span class="s">"N"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"M"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"D"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"P"</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>After the first instruction <code class="language-plaintext highlighter-rouge">move 1 from 2 to 1</code> We’ll have:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="s">"Z"</span><span class="p">,</span> <span class="s">"N"</span><span class="p">,</span> <span class="s">"D"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"M"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"P"</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>The next instruction brings us to this process of popping and appending in a much more noticeable way, though: <code class="language-plaintext highlighter-rouge">move 3 from 1 to 3</code>. After the first pop, we end up with:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="s">"Z"</span><span class="p">,</span> <span class="s">"N"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"M"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"P"</span><span class="p">,</span> <span class="s">"D"</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Notice we didn’t move <strong>3</strong> all at once, this means that our crates that are getting moved around will be getting reversed in order each time multiples are moved per instruction, as see in the second and third crates getting moved by this instruction:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[],</span>
  <span class="p">[</span><span class="s">"M"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"P"</span><span class="p">,</span> <span class="s">"D"</span><span class="p">,</span> <span class="s">"N"</span><span class="p">,</span> <span class="s">"Z"</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>We’ll do this process with the following:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">move</span> <span class="k">in</span> <span class="n">moves</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">numberOfCrates</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">movingCrate</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">move</span><span class="o">.</span><span class="n">fromStackIndex</span><span class="p">]</span><span class="o">.</span><span class="nf">popLast</span><span class="p">()</span><span class="o">!</span>
        <span class="n">stacks</span><span class="p">[</span><span class="n">move</span><span class="o">.</span><span class="n">toStackIndex</span><span class="p">]</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">movingCrate</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that our logic looks pretty much as we described it, the actual solution is fairly simple while the difficulty laid in the parsing for this problem!</p>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>After the rearrangement procedure completes, what crate ends up on top of each stack?</p>
</blockquote>

<p>Next up we’ve got a twist: we’re going to move all of the crates all at once. Now our second instruction in our example results in this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[],</span>
  <span class="p">[</span><span class="s">"M"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">],</span>
  <span class="p">[</span><span class="s">"P"</span><span class="p">,</span> <span class="s">"Z"</span><span class="p">,</span> <span class="s">"N"</span><span class="p">,</span> <span class="s">"D"</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Notice how the group of three crates from stack one, <code class="language-plaintext highlighter-rouge">Z, N, D</code> remains in the same order as they’re moved rather than being reversed due to the pop/append process? Instead of popping a single crate off at a time, we’ll just slice off the top using <code class="language-plaintext highlighter-rouge">suffix(from:)</code> to get the crates and <code class="language-plaintext highlighter-rouge">removeLast(_: Int)</code> to remove them from the stack we are moving them from, and <code class="language-plaintext highlighter-rouge">append(contentsOf:)</code> to add them all at once, in the same order that we removed them in, to our stack we are moving to. Writing some pseudo-code would give us something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let length = stacks[move.fromStackIndex].count
let slicePoint = length - move.numberOfCrates

let fromStack = stacks[move.fromStackIndex]

stacks[move.toStackIndex] = stacks[move.toStackIndex] + fromStack[slicePoint..&lt;length]
stacks[move.fromStackIndex] = fromStack[0..&lt;slicePoint]
</code></pre></div></div>

<p>We can make this a little more expressive using the <code class="language-plaintext highlighter-rouge">suffix(from:)</code>, <code class="language-plaintext highlighter-rouge">removeLast(_: Int)</code> and <code class="language-plaintext highlighter-rouge">append(contentsOf:)</code> functions:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">move</span> <span class="k">in</span> <span class="n">input</span><span class="o">.</span><span class="n">moves</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">length</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">move</span><span class="o">.</span><span class="n">fromStackIndex</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
    <span class="k">let</span> <span class="nv">slicePoint</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">move</span><span class="o">.</span><span class="n">numberOfCrates</span>

    <span class="k">let</span> <span class="nv">movingCrates</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">move</span><span class="o">.</span><span class="n">fromStackIndex</span><span class="p">]</span><span class="o">.</span><span class="nf">suffix</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">slicePoint</span><span class="p">)</span>

    <span class="n">stacks</span><span class="p">[</span><span class="n">move</span><span class="o">.</span><span class="n">fromStackIndex</span><span class="p">]</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">(</span><span class="n">move</span><span class="o">.</span><span class="n">numberOfCrates</span><span class="p">)</span>
    <span class="n">stacks</span><span class="p">[</span><span class="n">move</span><span class="o">.</span><span class="n">toStackIndex</span><span class="p">]</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">contentsOf</span><span class="p">:</span> <span class="n">movingCrates</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Some languages have a “removeAndReturn” method which might reduce the lines here by one, but this isn’t the worst considering half of it is calculating an index to start the suffix from!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/06/AoC-2022-Day-06.html">Day 06</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/04/AoC-2022-Day-04.html">Day 04</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 04 - The elves clean up base camp, we free up resources</title><link href="https://joshisa.ninja/aoc/2022/12/04/AoC-2022-Day-04.html" rel="alternate" type="text/html" title="AoC 2022 Day 04 - The elves clean up base camp, we free up resources" /><published>2022-12-04T23:59:00+00:00</published><updated>2022-12-04T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/04/AoC-2022-Day-04</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/04/AoC-2022-Day-04.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p>I felt that today’s puzzle was rather easy, but I acknowledge that a big part of that is because the swift language and standard library had all of the tools necessary built in to solve the problem with minimal fanfare. I also started solving the second part without knowing it before I finished reading the first part’s challenge, lol.</p>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>In how many assignment pairs does one range fully contain the other?</p>
</blockquote>

<p>Our input for today maps two elves per line, where each elf is assigned a contiguous range of sections to clean up. We’ve got to find how many of these elves are assigned to clean up sections that are completely assigned to their pair already. An elf assigned to 2-4 in the input is actually assigned to sections 2, 3, and 4 and this is starting to look awfully like the concept of a range of numbers. A lot of us have probably seen the following code in some form before:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="k">let</span> <span class="nv">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">6</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">// OR</span>
<span class="k">for</span> <span class="k">let</span> <span class="nv">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">5</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">..&lt;</code> and <code class="language-plaintext highlighter-rouge">...</code> operators are actually creating a range object in the background: <code class="language-plaintext highlighter-rouge">Range</code> for <code class="language-plaintext highlighter-rouge">..&lt;</code> which is a half-open range from the lower bound up to but not including the upper-bound and <code class="language-plaintext highlighter-rouge">...</code> for <code class="language-plaintext highlighter-rouge">ClosedRange</code> which is from the lower bound up to and including the upper bound. For the sake of convenience today, we’ll be using <code class="language-plaintext highlighter-rouge">ClosedRange</code>s. A single section range in the input looks like the following: <code class="language-plaintext highlighter-rouge">2-4</code> so we’ll split on <code class="language-plaintext highlighter-rouge">-</code>, convert the two parts to <code class="language-plaintext highlighter-rouge">Int</code>s and then map them to a <code class="language-plaintext highlighter-rouge">ClosedRange</code> with <code class="language-plaintext highlighter-rouge">...</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sectionToRange</span><span class="p">(</span><span class="n">_</span> <span class="nv">sectionString</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ClosedRange</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">parts</span> <span class="o">=</span> <span class="n">sectionString</span>
        <span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"-"</span><span class="p">,</span> <span class="nv">maxSplits</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">Int</span><span class="p">(</span><span class="kt">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span><span class="o">!</span> <span class="p">}</span>

    <span class="k">return</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">...</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To make things a little easier to understand, as per usual we’ll combine this into a container struct per line. Today’s will hold the two elves zone’s <code class="language-plaintext highlighter-rouge">ClosedRange</code>s and we’ll use our helper from above to build the two ranges:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ZonePairs</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">leftZone</span><span class="p">:</span> <span class="kt">ClosedRange</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">rightZone</span><span class="p">:</span> <span class="kt">ClosedRange</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ZonePairs</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">","</span><span class="p">,</span> <span class="nv">maxSplits</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">leftZone</span><span class="p">:</span> <span class="nf">sectionToRange</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="nv">rightZone</span><span class="p">:</span> <span class="nf">sectionToRange</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the neat bit, though: <code class="language-plaintext highlighter-rouge">Range</code> turns out to be incredibly helpful for us because it has <a href="https://developer.apple.com/documentation/swift/range/contains%28_:%29"><code class="language-plaintext highlighter-rouge">contains</code></a> which pretty much solve this first part of the challenge. Now that we’ve got our input mapped to an array of <code class="language-plaintext highlighter-rouge">ZonePairs</code> we can filter the array down to pairs where either the left or the right zone fully contain the right or left zone respectively and then simply count the number of zone pairs left:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">elfZonePairs</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">leftZone</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">rightZone</span><span class="p">)</span> <span class="o">||</span> <span class="nv">$0</span><span class="o">.</span><span class="n">rightZone</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">leftZone</span><span class="p">)</span> <span class="p">}</span>
    <span class="o">.</span><span class="n">count</span>
</code></pre></div></div>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>In how many assignment pairs do the ranges overlap?</p>
</blockquote>

<p>This part is actually even easier than the first part. As we’ve just seen, <code class="language-plaintext highlighter-rouge">Range</code> has a lot of provisions already, so we can go looking for something that’ll tell us if one <code class="language-plaintext highlighter-rouge">Range</code> overlaps another <code class="language-plaintext highlighter-rouge">Range</code> and sure enough we’ll come across <a href="https://developer.apple.com/documentation/swift/range/overlaps%28_:%29-7osha"><code class="language-plaintext highlighter-rouge">overlaps</code></a>. Now, instead of filtering down to the set of zone pairs that contains the other pair, we’re just filtering them down to the pairs that overlap:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">elfZonePairs</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">leftZone</span><span class="o">.</span><span class="nf">overlaps</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">rightZone</span><span class="p">)</span> <span class="p">}</span>
    <span class="o">.</span><span class="n">count</span>
</code></pre></div></div>

<p>And that’s it for today!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/05/AoC-2022-Day-05.html">Day 05</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/03/AoC-2022-Day-03.html">Day 03</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf</title><link href="https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03.html" rel="alternate" type="text/html" title="AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf" /><published>2022-12-03T23:59:00+00:00</published><updated>2022-12-03T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p><em>Updated Dec 12, 2022 to remove shorthand argument names in the last reduce
to help clarify what’s going on</em></p>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>Find the item type that appears in both compartments of each rucksack. What is the sum of the priorities of those item types?</p>
</blockquote>

<p>So we’ve got an elf’s rucksack per line in our input. Each rucksack has two compartments and there is an item that is present in both compartments that we need to identify. Basically, we need to do an intersection between the two compartments and then convert the character representing the item into a “priority” number.</p>

<p>Unfortunately Swift doesn’t have a built-in intersection for Arrays, but does have intersections for Sets, so let’s parse our input into those. As we did for yesterday, let’s make a little container to hold our rucksack contents to make our code a little easier to read:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Rucksack</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">compartmentA</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">Character</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">compartmentB</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">Character</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As stated above, we’ll benefit from using Sets, so the first part reduces down to something like the following, using our new <code class="language-plaintext highlighter-rouge">Rucksack</code> struct:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">itemInBothCompartments</span> <span class="o">=</span> <span class="n">rucksack</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">rucksack</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span>
</code></pre></div></div>

<p>Before we finish that thought, though, let’s finish parsing an elf’s line. Now that we’ve got our container struct we need to do two things: split a line from our input in half and then convert each half into a <code class="language-plaintext highlighter-rouge">Set</code> of <code class="language-plaintext highlighter-rouge">Characters</code>. Thankfully we can use swifts <code class="language-plaintext highlighter-rouge">Array#prefix()</code> and <code class="language-plaintext highlighter-rouge">Array#suffix()</code> methods to get the first half and the second half of the line in a fairly easy to read way. We can also map over the resulting arrays and initialize a <code class="language-plaintext highlighter-rouge">Character</code> before we initialize our <code class="language-plaintext highlighter-rouge">Set</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Rucksack</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">halfLength</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">count</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">let</span> <span class="nv">compartmentAArray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="n">halfLength</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Character</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">compartmentBArray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">suffix</span><span class="p">(</span><span class="n">halfLength</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Character</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">compartmentA</span><span class="p">:</span> <span class="kt">Set</span><span class="p">(</span><span class="n">compartmentAArray</span><span class="p">),</span>
        <span class="nv">compartmentB</span><span class="p">:</span> <span class="kt">Set</span><span class="p">(</span><span class="n">compartmentBArray</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this, one last part of the puzzle remains: Once we have the intersection, we have a character that needs to be mapped to a “priority” number using the following rules:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">a</code> through <code class="language-plaintext highlighter-rouge">z</code> maps to 1 - 26</li>
  <li><code class="language-plaintext highlighter-rouge">A</code> through <code class="language-plaintext highlighter-rouge">Z</code> maps to 27 - 52</li>
</ul>

<p>If you’re familiar with the ASCII representations for a-z and A-Z you’ll immediately see that even if we take the ASCII number value for our characters, <code class="language-plaintext highlighter-rouge">A</code> - <code class="language-plaintext highlighter-rouge">Z</code> maps to a lower range (65-90) than <code class="language-plaintext highlighter-rouge">a</code> - <code class="language-plaintext highlighter-rouge">z</code> (97-122) and neither of those align with our 1-52 range of values! We’ll have to subtract a fixed value, but we’ll also have to have two different fixed values, depending on if the character is upper-case or lower. Let’s remap <code class="language-plaintext highlighter-rouge">A</code>-<code class="language-plaintext highlighter-rouge">Z</code> first:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">remapCharToPriority</span><span class="p">(</span><span class="n">_</span> <span class="nv">char</span><span class="p">:</span> <span class="kt">Character</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">rawAsciiValue</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">asciiValue</span><span class="o">!</span><span class="p">)</span>

    <span class="c1">// A-Z have priority of 27 - 52</span>
    <span class="k">return</span> <span class="n">rawAsciiValue</span> <span class="o">-</span> <span class="mi">38</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A few things to note here: <code class="language-plaintext highlighter-rouge">Character#asciiValue</code> returns an optional. We’re going to force unwrap the result since we are trusting that our input falls only within ASCII values. You’d probably want to add some additional sanity checks here for real-world problems but since we know that our input is going to be well formed, we’ll get away with this. Secondly, <code class="language-plaintext highlighter-rouge">Character#asciiValue</code> returns an <code class="language-plaintext highlighter-rouge">UInt8</code> instead of an <code class="language-plaintext highlighter-rouge">Int</code> which could be fine, but we’ll overflow <code class="language-plaintext highlighter-rouge">UInt8</code>, which can only store from 0 to 255, once we start adding together priorities from other elves’ rucksacks. To get around this we convert the <code class="language-plaintext highlighter-rouge">UInt8</code> to an <code class="language-plaintext highlighter-rouge">Int</code> which has a far wider range that it can store (which means we don’t have to worry about this conversion going south at any point too). Finally, we subtract 38 which means that <code class="language-plaintext highlighter-rouge">A</code> will map to <code class="language-plaintext highlighter-rouge">27</code> (<code class="language-plaintext highlighter-rouge">65 - 27 = 38</code>) and <code class="language-plaintext highlighter-rouge">Z</code> to <code class="language-plaintext highlighter-rouge">52</code> as we expect.</p>

<p>We’ve got one case to handle here, however: <code class="language-plaintext highlighter-rouge">a</code> which is <code class="language-plaintext highlighter-rouge">97</code> in ASCII will currently map to <code class="language-plaintext highlighter-rouge">59</code> which isn’t what we want. We need to add an if branch for when the ASCII value is 97 or higher and return the ASCII value subtracting <code class="language-plaintext highlighter-rouge">96</code> in order to correctly map the lower-case characters:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">remapCharToPriority</span><span class="p">(</span><span class="n">_</span> <span class="nv">char</span><span class="p">:</span> <span class="kt">Character</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">rawAsciiValue</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">asciiValue</span><span class="o">!</span><span class="p">)</span>

    <span class="c1">// a-z have priority of 1 - 26</span>
    <span class="k">if</span> <span class="n">rawAsciiValue</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rawAsciiValue</span> <span class="o">-</span> <span class="mi">96</span>
    <span class="p">}</span>

    <span class="c1">// A-Z have priority of 27 - 52</span>
    <span class="k">return</span> <span class="n">rawAsciiValue</span> <span class="o">-</span> <span class="mi">38</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that we’ve got all we need to solve this part of the puzzle:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rucksacks</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">sack</span> <span class="k">in</span> <span class="n">sack</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">sack</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="o">!</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">remapCharToPriority</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>For each rucksack, we find the item that exists in both compartments. We can force unwrap this because, again, we know that our input will have a duplicate per line but we’d want some better error handling for real-life applications. Then we remap each duplicate item into its priority and finally sum it all together.</p>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>Find the item type that corresponds to the badges of each three-Elf group. What is the sum of the priorities of those item types?</p>
</blockquote>

<p>Now, instead of finding the duplicated item across a single rucksack’s compartments, we’re looking for a duplicated item across three elfs’ rucksacks. It turns out that we can keep our mapping logic the same, and our only changes will be how we apply intersections across the rucksacks. The first thing we can change is unioning the two compartments of each rucksack together since we don’t care about duplicates for a single elf anymore:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rucksacks</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">sack</span> <span class="k">in</span> <span class="n">sack</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">union</span><span class="p">(</span><span class="n">sack</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>The next thing we need to do is divide the rucksacks into groups of three. Unfortunately swift doesn’t have a built in <code class="language-plaintext highlighter-rouge">cons</code>, <code class="language-plaintext highlighter-rouge">pairs</code>, or <code class="language-plaintext highlighter-rouge">slicesOf</code> function for any data structure, so we’ll have to make our own. We’ll do this using an extension onto Array so let’s write our signature that we’re aiming for first:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Array</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">chunked</span><span class="p">(</span><span class="n">into</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Element</span><span class="p">]]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="c1">// something ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Thankfully the swift standard library includes a neat little <a href="https://developer.apple.com/documentation/swift/stride%28from:to:by:%29"><code class="language-plaintext highlighter-rouge">stride</code></a> function:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">stride</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">from</span> <span class="nv">start</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span>
    <span class="n">to</span> <span class="nv">end</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span>
    <span class="n">by</span> <span class="nv">stride</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Stride</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">StrideTo</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">T</span> <span class="p">:</span> <span class="kt">Strideable</span>
</code></pre></div></div>

<p>We can use this to produce a sequence of the starting index for each group:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Array</span><span class="p">(</span><span class="nf">stride</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="nv">by</span><span class="p">:</span> <span class="mi">3</span><span class="p">))</span>
<span class="err">$</span><span class="kt">R</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="n">values</span> <span class="p">{</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this we can map over this sequence, and take a slice from the Array <code class="language-plaintext highlighter-rouge">self</code> (since we’re in an extension of <code class="language-plaintext highlighter-rouge">Array</code>) and convert it to a standalone array for convenience in a few minutes with something like the following:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Array</span><span class="p">(</span><span class="k">self</span><span class="p">[</span><span class="nv">$0</span> <span class="o">..&lt;</span> <span class="p">(</span><span class="nv">$0</span> <span class="o">+</span> <span class="n">size</span><span class="p">)])</span>
</code></pre></div></div>

<p>Leaving us with the final following implementation:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Array</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">chunked</span><span class="p">(</span><span class="n">into</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Element</span><span class="p">]]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">stride</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="nv">by</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span>
            <span class="kt">Array</span><span class="p">(</span><span class="k">self</span><span class="p">[</span><span class="nv">$0</span> <span class="o">..&lt;</span> <span class="nv">$0</span> <span class="o">+</span> <span class="n">size</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It should be noted that this method will fail with an out-of-bounds error for arrays that are not nicely groupable, so an extra bit of safety would either be to implement that as a check and throw an error if count is not cleanly divisible by 3 or to use something like <code class="language-plaintext highlighter-rouge">min($0 + size, count)</code> to cut the last group into a smaller slice without failing.</p>

<p>With this in place, we can finish up our task as we can now group the elves into sets of 3. We’ll reduce each group, calling <code class="language-plaintext highlighter-rouge">Set#intersection</code> to compute the final intersection of the group to determine what they’ve gotten duplicated amongst themselves. After that, we’ll return to our first solution and map each item to the priority number and finally sum it all together:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rucksacks</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">sack</span> <span class="k">in</span> <span class="n">sack</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">union</span><span class="p">(</span><span class="n">sack</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">chunked</span><span class="p">(</span><span class="nv">into</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">chunk</span> <span class="k">in</span>
        <span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="o">..&lt;</span><span class="n">chunk</span><span class="o">.</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{</span> <span class="n">innerMemo</span><span class="p">,</span> <span class="n">prioritySet</span> <span class="k">in</span>
            <span class="n">innerMemo</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">prioritySet</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="n">first</span><span class="o">!</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">remapCharToPriority</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>We’re using a reduce here so that our code is a little more configurable and maintainable, but it boils down to something like:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<p>And with that our second star is within reach!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/04/AoC-2022-Day-04.html">Day 04</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/02/AoC-2022-Day-02.html">Day 02</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 02 - The elves play Rock, Paper, Scissors, we win</title><link href="https://joshisa.ninja/aoc/2022/12/02/AoC-2022-Day-02.html" rel="alternate" type="text/html" title="AoC 2022 Day 02 - The elves play Rock, Paper, Scissors, we win" /><published>2022-12-02T23:59:00+00:00</published><updated>2022-12-02T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/02/AoC-2022-Day-02</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/02/AoC-2022-Day-02.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p>As with yesterdays solution I ended up just taking a fairly naive approach here rather than decomposing the problem into the math problem that others have done.</p>
<h2 id="part-one">Part One</h2>
<blockquote>
  <p>What would your total score be if everything goes exactly according to your strategy guide?</p>
</blockquote>

<p>Our input has a round’s strategy per line, where a strategy is the opponent’s move and our move, separated by a space.
The opponent’s move is encoded as:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">A</code> Rock</li>
  <li><code class="language-plaintext highlighter-rouge">B</code> Paper</li>
  <li><code class="language-plaintext highlighter-rouge">C</code> Scissors</li>
</ul>

<p>And our move is encoded as:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">X</code> Rock</li>
  <li><code class="language-plaintext highlighter-rouge">Y</code> Paper</li>
  <li><code class="language-plaintext highlighter-rouge">Z</code> Scissors</li>
</ul>

<p>Additionally, we find out that each move has a score assigned to it:</p>
<ul>
  <li>Rock =&gt; 1</li>
  <li>Paper =&gt; 2</li>
  <li>Scissors =&gt; 3</li>
</ul>

<p>Finally, we have a set of rules about which move defeats which other move:</p>
<ul>
  <li>Rock defeats Scissors</li>
  <li>Scissors defeats Paper</li>
  <li>Paper defeats Scissors</li>
</ul>

<hr />

<p>So we now know that our problem space is confined to these three moves and their respective rules, each move has a score assigned to it and that our input uses two different characters to represent the same move. We could take this information to make a few functions like the following:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">score</span><span class="p">(</span><span class="n">_</span> <span class="nv">char</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">char</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">"A"</span><span class="p">,</span> <span class="s">"X"</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="s">"B"</span><span class="p">,</span> <span class="s">"Y"</span><span class="p">:</span> <span class="k">return</span> <span class="mi">2</span>
        <span class="k">case</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"Z"</span><span class="p">:</span> <span class="k">return</span> <span class="mi">3</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">defeats</span><span class="p">(</span><span class="n">_</span> <span class="nv">char</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">char</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">"A"</span><span class="p">:</span> <span class="k">return</span> <span class="s">"Y"</span>
        <span class="k">case</span> <span class="s">"B"</span><span class="p">:</span> <span class="k">return</span> <span class="s">"Z"</span>
        <span class="k">case</span> <span class="s">"C"</span><span class="p">:</span> <span class="k">return</span> <span class="s">"X"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But this presents us with a few problems:</p>
<ul>
  <li>Our codes problem space isn’t confined to the three moves because strings can be a lot more than just those 6 characters. Additionally, the compiler won’t alert us if we make a typo so we’re not really taking advantage of the language as well as we could</li>
  <li>Our code is intrinsically tied to the input format</li>
  <li>It’s difficult to read and quickly comprehend, we’ll need comments everywhere denoting what <code class="language-plaintext highlighter-rouge">"A"</code> is</li>
</ul>

<p>A good way to work around these problems is to ensure that our code only operates within a confined problem space, letting the language do the work of validating that we stay within the bounds and setting up a boundary between the input and our problem space in the form of a function that’ll map the input. This narrows the place where we worry about the input format down to one space and free up our solution code to be both more expressive and decoupled. To do this we’ll make an enum backed by the scores as integer values:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Move</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">rock</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="n">paper</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">case</span> <span class="n">scissors</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using this enum, we can easily map both <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">X</code> to <code class="language-plaintext highlighter-rouge">Move.rock</code>, so we can make a quick mapping function that’ll take all 6 characters in our input and convert them to our nice enum. This establishes the boundary between the input and our problem space and is the only place we have to worry about the input format. In other words, the decoupling here lets us easy switch out characters and handle adapting to different input formats in the future, leading to more maintainable code.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">mapStringToMove</span><span class="p">(</span><span class="n">_</span> <span class="nv">part</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Move</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">part</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">"A"</span><span class="p">,</span> <span class="s">"X"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">rock</span>
        <span class="k">case</span> <span class="s">"B"</span><span class="p">,</span> <span class="s">"Y"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">paper</span>
        <span class="k">case</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"Z"</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">scissors</span>
        <span class="k">default</span><span class="p">:</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Unrecognized input </span><span class="se">\(</span><span class="n">part</span><span class="se">)</span><span class="s">!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that we can map our input down to our problem space, we’ll make a little container that’ll represent a single round and make one last parsing related function that’ll convert a line from our input into a <code class="language-plaintext highlighter-rouge">RoundStrategy</code>. This container isn’t strictly necessary as you could use a tuple, but I find the expressiveness of the struct a lot more maintainable and lends itself to more “self-explaining code”:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">RoundStrategy</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">theirMove</span><span class="p">:</span> <span class="kt">Move</span>
    <span class="k">let</span> <span class="nv">myMove</span><span class="p">:</span> <span class="kt">Move</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">RoundStrategy</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">" "</span><span class="p">,</span> <span class="nv">maxSplits</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">theirMove</span><span class="p">:</span> <span class="nf">stringToMove</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="nv">myMove</span><span class="p">:</span> <span class="nf">stringToMove</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’ll add a few helper functions to the <code class="language-plaintext highlighter-rouge">RoundStrategy</code> container in a little bit but for now this will be enough. Now we should be able to map our entire input file into an array of <code class="language-plaintext highlighter-rouge">RoundStrategy</code>s which lets us focus on building out our scoring functionality.</p>

<p>We know that for a single round, if the opponents move is the same as mine, then the round is a draw and the scoring is simply the score for our move plus <code class="language-plaintext highlighter-rouge">3</code>. Let’s add a <code class="language-plaintext highlighter-rouge">score</code> function to our <code class="language-plaintext highlighter-rouge">RoundStrategy</code> struct and encode this first rule:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">RoundStrategy</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">theirMove</span><span class="p">:</span> <span class="kt">Move</span>
    <span class="k">let</span> <span class="nv">myMove</span><span class="p">:</span> <span class="kt">Move</span>

    <span class="kd">func</span> <span class="nf">score</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">theirMove</span> <span class="o">==</span> <span class="n">myMove</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">myMove</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">+</span> <span class="mi">3</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we’ve got two other outcomes to consider:</p>
<ul>
  <li>My move defeats their move</li>
  <li>Their move defeats my move</li>
</ul>

<p>To try and keep the expressiveness we’ve already established, and trying to anticipate any changes we’ll need for part two, we can make another container and a small lookup function to map one move to the move that it’ll defeat. Then we can simply run their move through the lookup helper to get which move it’ll defeat. If that looked up move is ours, we know we’ve lost and otherwise we know we’ve won:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CounterMoves</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">losingMove</span><span class="p">:</span> <span class="kt">Move</span>
<span class="p">}</span>

<span class="c1">// Rock defeats Scissors, defeated by Paper</span>
<span class="c1">// Paper defeats Rock, defeated by Scissors</span>
<span class="c1">// Scissors defeats Paper, defeated by Rock</span>
<span class="kd">func</span> <span class="nf">possibleCountersFor</span><span class="p">(</span><span class="n">_</span> <span class="nv">move</span><span class="p">:</span> <span class="kt">Move</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CounterMoves</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">move</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">rock</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">losingMove</span><span class="p">:</span> <span class="o">.</span><span class="n">scissors</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">paper</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">losingMove</span><span class="p">:</span> <span class="o">.</span><span class="n">rock</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">scissors</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">losingMove</span><span class="p">:</span> <span class="o">.</span><span class="n">paper</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using a struct here means that if we need to, say, encode the move that’ll defeat their move as well as which move is defeated by their move, we can just add another field to the struct without too many code changes.</p>

<p>Using this in practice looks a bit like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">myPossibleMoves</span> <span class="o">=</span> <span class="nf">possibleCountersFor</span><span class="p">(</span><span class="n">theirMove</span><span class="p">)</span>
<span class="k">if</span> <span class="n">myPossibleMoves</span><span class="o">.</span><span class="n">losingMove</span> <span class="o">==</span> <span class="n">myMove</span> <span class="p">{</span>
    <span class="c1">// I've lost :-(</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// I've won! :-D</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s add that to our <code class="language-plaintext highlighter-rouge">RoundStragety#score()</code> function:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">score</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">theirMove</span> <span class="o">==</span> <span class="n">myMove</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">myMove</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">+</span> <span class="mi">3</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">myPossibleMoves</span> <span class="o">=</span> <span class="nf">possibleCountersFor</span><span class="p">(</span><span class="n">theirMove</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">myPossibleMoves</span><span class="o">.</span><span class="n">losingMove</span> <span class="o">==</span> <span class="n">myMove</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">myMove</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">myMove</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">+</span> <span class="mi">6</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that we should be able to write some sanity check tests around the scoring functionality for all possible combinations and ensure that it scores correctly. For example, using the puzzles example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nv">day02Tests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">testRoundScoring</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="kt">RoundStrategy</span><span class="p">(</span><span class="nv">theirMove</span><span class="p">:</span> <span class="o">.</span><span class="n">rock</span><span class="p">,</span> <span class="nv">myMove</span><span class="p">:</span> <span class="o">.</span><span class="n">paper</span><span class="p">)</span><span class="o">.</span><span class="nf">score</span><span class="p">(),</span> <span class="mi">8</span><span class="p">)</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="kt">RoundStrategy</span><span class="p">(</span><span class="nv">theirMove</span><span class="p">:</span> <span class="o">.</span><span class="n">paper</span><span class="p">,</span> <span class="nv">myMove</span><span class="p">:</span> <span class="o">.</span><span class="n">rock</span><span class="p">)</span><span class="o">.</span><span class="nf">score</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="kt">RoundStrategy</span><span class="p">(</span><span class="nv">theirMove</span><span class="p">:</span> <span class="o">.</span><span class="n">scissors</span><span class="p">,</span> <span class="nv">myMove</span><span class="p">:</span> <span class="o">.</span><span class="n">scissors</span><span class="p">)</span><span class="o">.</span><span class="nf">score</span><span class="p">(),</span> <span class="mi">6</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With tests written and passing we can tie everything together, parsing our full puzzle input into an array of <code class="language-plaintext highlighter-rouge">RoundStragety</code>s and then simply map them to each round’s score and sum all the scores up. You can do this in one go using a reduce as well:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rounds</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="n">memo</span><span class="p">,</span> <span class="n">round</span> <span class="k">in</span> <span class="n">memo</span> <span class="o">+</span> <span class="n">round</span><span class="o">.</span><span class="nf">score</span><span class="p">()</span> <span class="p">})</span>
</code></pre></div></div>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>Following the Elf’s instructions for the second column, what would your total score be if everything goes exactly according to your strategy guide?</p>
</blockquote>

<p>This just in: we were wrong! The second character for each round isn’t our move but the outcome of the round. We’ll have to figure out what move to make based off of our opponents move and the outcome of the round. The outcome is mapped as such:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">X</code> we need to lose</li>
  <li><code class="language-plaintext highlighter-rouge">Y</code> we need to cause a draw</li>
  <li><code class="language-plaintext highlighter-rouge">Z</code> we need to win</li>
</ul>

<p>There are a couple of different ways to tackle this problem, some of which will be a little more expressive than the approach I’m going to take. We’ve got a problem with our current <code class="language-plaintext highlighter-rouge">RoundStrategy</code> with this twist: the <code class="language-plaintext highlighter-rouge">.myMove</code> is actually the outcome of the game and we have to narrow it down to which move we should actually take. However, after we figure that move out, the scoring stays the same. To make things easier, why don’t we just make a utility that’ll take in an incorrect <code class="language-plaintext highlighter-rouge">RoundStrategy</code> and produce a corrected <code class="language-plaintext highlighter-rouge">RoundStrategy</code> with the correct <code class="language-plaintext highlighter-rouge">myMove</code>? We can start off with the easy case: when the outcome is a draw, or when the incoming <code class="language-plaintext highlighter-rouge">myMove</code> is a <code class="language-plaintext highlighter-rouge">.paper</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We've got their side and the outcome is under `myMove` because naming is hard</span>
<span class="c1">// myMove .rock =&gt; lose</span>
<span class="c1">// myMove .paper =&gt; draw</span>
<span class="c1">// myMove .scissors =&gt; win</span>
<span class="kd">func</span> <span class="nf">remapFromOutcomeToMyMove</span><span class="p">(</span><span class="n">_</span> <span class="nv">round</span><span class="p">:</span> <span class="kt">RoundStrategy</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">RoundStrategy</span> <span class="p">{</span>
    <span class="c1">// Draw so myMove is their move</span>
    <span class="k">if</span> <span class="n">round</span><span class="o">.</span><span class="n">myMove</span> <span class="o">==</span> <span class="o">.</span><span class="n">paper</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">theirMove</span><span class="p">:</span> <span class="n">round</span><span class="o">.</span><span class="n">theirMove</span><span class="p">,</span> <span class="nv">myMove</span><span class="p">:</span> <span class="n">round</span><span class="o">.</span><span class="n">theirMove</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From here we can reuse our existing <code class="language-plaintext highlighter-rouge">possibleCountersFor()</code> function to get the case of when the outcome is a loss, or when <code class="language-plaintext highlighter-rouge">.myMove</code> is a <code class="language-plaintext highlighter-rouge">.rock</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">myPossibleMoves</span> <span class="o">=</span> <span class="nf">possibleCountersFor</span><span class="p">(</span><span class="n">round</span><span class="o">.</span><span class="n">theirMove</span><span class="p">)</span>

<span class="c1">// I need to lose, what their move wins against is my move</span>
<span class="k">if</span> <span class="n">round</span><span class="o">.</span><span class="n">myMove</span> <span class="o">==</span> <span class="o">.</span><span class="n">rock</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">theirMove</span><span class="p">:</span> <span class="n">round</span><span class="o">.</span><span class="n">theirMove</span><span class="p">,</span> <span class="nv">myMove</span><span class="p">:</span> <span class="n">myPossibleMoves</span><span class="o">.</span><span class="n">losingMove</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To find the correct move for the last case, where we need to win we have a few options but I think it’d be easiest to simply add another field to our <code class="language-plaintext highlighter-rouge">CounterMoves</code> struct, one for the corresponding move that’ll defeat the looked-up move instead:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CounterMoves</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">losingMove</span><span class="p">:</span> <span class="kt">Move</span>
    <span class="k">let</span> <span class="nv">winningMove</span><span class="p">:</span> <span class="kt">Move</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now we just need to adjust our look up function to include this <code class="language-plaintext highlighter-rouge">winningMove</code> as well:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Rock defeats Scissors, defeated by Paper</span>
<span class="c1">// Paper defeats Rock, defeated by Scissors</span>
<span class="c1">// Scissors defeats Paper, defeated by Rock</span>
<span class="kd">func</span> <span class="nf">possibleCountersFor</span><span class="p">(</span><span class="n">_</span> <span class="nv">move</span><span class="p">:</span> <span class="kt">Move</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CounterMoves</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">move</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">rock</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">losingMove</span><span class="p">:</span> <span class="o">.</span><span class="n">scissors</span><span class="p">,</span> <span class="nv">winningMove</span><span class="p">:</span> <span class="o">.</span><span class="n">paper</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">paper</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">losingMove</span><span class="p">:</span> <span class="o">.</span><span class="n">rock</span><span class="p">,</span> <span class="nv">winningMove</span><span class="p">:</span> <span class="o">.</span><span class="n">scissors</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">scissors</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">losingMove</span><span class="p">:</span> <span class="o">.</span><span class="n">paper</span><span class="p">,</span> <span class="nv">winningMove</span><span class="p">:</span> <span class="o">.</span><span class="n">rock</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And that’s it, the secret sauce which gives us the final case:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">myPossibleMoves</span> <span class="o">=</span> <span class="nf">possibleCountersFor</span><span class="p">(</span><span class="n">round</span><span class="o">.</span><span class="n">theirMove</span><span class="p">)</span>

<span class="c1">// I need to win, what their move loses against is my move</span>
<span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">theirMove</span><span class="p">:</span> <span class="n">round</span><span class="o">.</span><span class="n">theirMove</span><span class="p">,</span> <span class="nv">myMove</span><span class="p">:</span> <span class="n">myPossibleMoves</span><span class="o">.</span><span class="n">winningMove</span><span class="p">)</span>
</code></pre></div></div>

<p>Now all we have to do is adjust our reduce call from part one to first remap the struct to get our correct moves in place before calculating the score:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rounds</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="n">memo</span><span class="p">,</span> <span class="n">round</span> <span class="k">in</span>
    <span class="n">memo</span> <span class="o">+</span> <span class="kt">RoundStrategy</span><span class="o">.</span><span class="nf">remapFromOutcomeToMyMove</span><span class="p">(</span><span class="n">round</span><span class="p">)</span><span class="o">.</span><span class="nf">score</span><span class="p">()</span>
<span class="p">})</span>
</code></pre></div></div>

<p>And with that, part two is also solved!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/03/AoC-2022-Day-03.html">Day 03</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/01/AoC-2022-Day-01.html">Day 01</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">AoC 2022 Day 01 - The elves count calories, we do an intro</title><link href="https://joshisa.ninja/aoc/2022/12/01/AoC-2022-Day-01.html" rel="alternate" type="text/html" title="AoC 2022 Day 01 - The elves count calories, we do an intro" /><published>2022-12-01T23:59:00+00:00</published><updated>2022-12-01T23:59:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/01/AoC-2022-Day-01</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/01/AoC-2022-Day-01.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p><em>Updated Dec 12, 2022 to remove shorthand argument names in the last reduce
to help clarify what’s going on</em></p>

<p>Welcome back to Advent of Code 2022! I haven’t written about my experience using OCaml for last year’s puzzles yet, but I figured I’d try to get a head start on this year while it’s all fresh in my mind. This year I’ll be trying to solve the puzzles using small swift CLI apps and will be trying to do write-ups of my solutions as I go.</p>

<p>For the most part, I’m not going for speed or cleverness so much as expressiveness and maintainability. I like to try and focus on learning patterns that lend themselves to understanding the code quicker 7 months later and to think about what adding additional features or changing requirements on the code could mean. I’m also not going to be focusing on the superfluous and boilerplate code that wraps and integrates my solutions into a CLI and I’m assuming that you the reader has enough general knowledge to do tasks like reading and splitting an input file by newlines and familiarity with iterators and map/reduce functions.</p>

<p>Since this is the first day, however, let’s take a look at how I’ve got this all set up just for reference. Each day I’ll scaffold a new CLI app using the swift package manager:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swift package init <span class="nt">--type</span> executable
</code></pre></div></div>

<p>Then I’ll add in the <a href="https://github.com/apple/swift-argument-parser">Swift Argument Parser</a> package. I’ll use a slightly modified <code class="language-plaintext highlighter-rouge">Package.swift</code> as well which I can copy-paste to the next day to hit the ground running without needing to worry about changing anything for each day’s different name:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// swift-tools-version: 5.7</span>

<span class="kd">import</span> <span class="kt">PackageDescription</span>
<span class="kd">import</span> <span class="kt">Foundation</span>

<span class="c1">// Turns the directory "AOC/2022/day04" into just "day04" for example</span>
<span class="k">let</span> <span class="nv">dayName</span> <span class="o">=</span> <span class="p">(</span><span class="kt">FileManager</span><span class="p">()</span><span class="o">.</span><span class="n">currentDirectoryPath</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">lastPathComponent</span>

<span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="n">dayName</span><span class="p">,</span>
    <span class="nv">platforms</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="nf">macOS</span><span class="p">(</span><span class="o">.</span><span class="n">v13</span><span class="p">)],</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">package</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="s">"https://github.com/apple/swift-argument-parser"</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="s">"1.2.0"</span><span class="p">)</span>
    <span class="p">],</span>
    <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">executableTarget</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="n">dayName</span><span class="p">,</span>
            <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="nf">product</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"ArgumentParser"</span><span class="p">,</span> <span class="nv">package</span><span class="p">:</span> <span class="s">"swift-argument-parser"</span><span class="p">)]),</span>
        <span class="o">.</span><span class="nf">testTarget</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">dayName</span><span class="se">)</span><span class="s">Tests"</span><span class="p">,</span>
            <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="nf">target</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">dayName</span><span class="p">)]),</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>And finally I’ll use a boilerplate for the command under <code class="language-plaintext highlighter-rouge">Sources/dayXX/dayXX.swift</code> that looks a bit like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">OSLog</span>
<span class="kd">import</span> <span class="kt">ArgumentParser</span>

<span class="k">let</span> <span class="nv">dayName</span> <span class="o">=</span> <span class="p">(</span><span class="kt">FileManager</span><span class="p">()</span><span class="o">.</span><span class="n">currentDirectoryPath</span> <span class="k">as</span> <span class="kt">NSString</span><span class="p">)</span><span class="o">.</span><span class="n">lastPathComponent</span>
<span class="k">let</span> <span class="nv">dayNumber</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">dayName</span><span class="o">.</span><span class="nf">components</span><span class="p">(</span><span class="nv">separatedBy</span><span class="p">:</span> <span class="kt">CharacterSet</span><span class="o">.</span><span class="n">decimalDigits</span><span class="o">.</span><span class="n">inverted</span><span class="p">)</span><span class="o">.</span><span class="nf">joined</span><span class="p">())</span> <span class="p">??</span> <span class="mi">0</span>

<span class="kd">extension</span> <span class="kt">Logger</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">parsing</span> <span class="o">=</span> <span class="kt">Logger</span><span class="p">(</span><span class="nv">subsystem</span><span class="p">:</span> <span class="s">"com.aoc22.</span><span class="se">\(</span><span class="n">dayName</span><span class="se">)</span><span class="s">"</span><span class="p">,</span> <span class="nv">category</span><span class="p">:</span> <span class="s">"Parsing"</span><span class="p">)</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Logger</span><span class="p">(</span><span class="nv">subsystem</span><span class="p">:</span> <span class="s">"com.aoc22.</span><span class="se">\(</span><span class="n">dayName</span><span class="se">)</span><span class="s">"</span><span class="p">,</span> <span class="nv">category</span><span class="p">:</span> <span class="s">"Solution"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">@main</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Challenge</span><span class="p">:</span> <span class="kt">ParsableCommand</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">var</span> <span class="nv">configuration</span> <span class="o">=</span> <span class="kt">CommandConfiguration</span><span class="p">(</span>
        <span class="nv">abstract</span><span class="p">:</span> <span class="s">"Day </span><span class="se">\(</span><span class="n">dayNumber</span><span class="se">)</span><span class="s">!"</span><span class="p">,</span>

        <span class="nv">version</span><span class="p">:</span> <span class="s">"1.0.0"</span><span class="p">,</span>

        <span class="nv">subcommands</span><span class="p">:</span> <span class="p">[</span><span class="kt">PartOne</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="kt">PartTwo</span><span class="o">.</span><span class="k">self</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">BaseOptions</span><span class="p">:</span> <span class="kt">ParsableArguments</span> <span class="p">{</span>
    <span class="kd">@Argument</span><span class="p">(</span><span class="nv">help</span><span class="p">:</span> <span class="s">"The file to work upon for the puzzle input"</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">inputFile</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"input"</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Challenge</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="kt">PartOne</span><span class="p">:</span> <span class="kt">ParsableCommand</span> <span class="p">{</span>
        <span class="kd">static</span> <span class="k">var</span> <span class="nv">configuration</span> <span class="o">=</span> <span class="kt">CommandConfiguration</span><span class="p">(</span>
            <span class="nv">abstract</span><span class="p">:</span> <span class="s">""</span>
        <span class="p">)</span>

        <span class="kd">@OptionGroup</span> <span class="k">var</span> <span class="nv">options</span><span class="p">:</span> <span class="kt">BaseOptions</span>

        <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">parsedInput</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">()</span><span class="o">.</span><span class="nf">parseFile</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">inputFile</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="nf">solve</span><span class="p">(</span><span class="n">parsedInput</span><span class="p">)</span>

            <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">solution</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kd">func</span> <span class="nf">solve</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="p">[</span><span class="kt">ParsedLine</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="kt">PartTwo</span><span class="p">:</span> <span class="kt">ParsableCommand</span> <span class="p">{</span>
        <span class="kd">static</span> <span class="k">var</span> <span class="nv">configuration</span> <span class="o">=</span> <span class="kt">CommandConfiguration</span><span class="p">(</span>
            <span class="nv">abstract</span><span class="p">:</span> <span class="s">""</span>
        <span class="p">)</span>

        <span class="kd">@OptionGroup</span> <span class="k">var</span> <span class="nv">options</span><span class="p">:</span> <span class="kt">BaseOptions</span>

        <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">parsedInput</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">()</span><span class="o">.</span><span class="nf">parseFile</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">inputFile</span><span class="p">)</span>
            <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="nf">solve</span><span class="p">(</span><span class="n">parsedInput</span><span class="p">)</span>

            <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">solution</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="kd">func</span> <span class="nf">solve</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="p">[</span><span class="kt">ParsedLine</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">typealias</span> <span class="kt">ParsedLine</span> <span class="o">=</span> <span class="kt">String</span><span class="c1">// TODO: Fill me in</span>

<span class="kd">struct</span> <span class="kt">Parser</span> <span class="p">{</span>
    <span class="kd">fileprivate</span> <span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ParsedLine</span> <span class="p">{</span>
        <span class="c1">// TODO: Fill me in</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">parseString</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">ParsedLine</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">input</span>
            <span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">parseLine</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">parseFile</span><span class="p">(</span><span class="n">_</span> <span class="nv">filename</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">ParsedLine</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">fileURLWithPath</span><span class="p">:</span> <span class="n">filename</span><span class="p">)</span>

        <span class="k">guard</span> <span class="k">let</span> <span class="nv">contents</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="kt">String</span><span class="p">(</span><span class="nv">contentsOf</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">encoding</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">fatalError</span><span class="p">(</span><span class="s">"Couldn't parse the file!"</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nf">parseString</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This gives me a quick and ready structure, leaving me with the details of how a line from the input is parsed and what that resulting container looks like, letting me focus on writing a solution by filling in <code class="language-plaintext highlighter-rouge">parseLine()</code> and the two <code class="language-plaintext highlighter-rouge">solve()</code>s without fussing with the setup. I’ve got a few other patterns setup in here too, such as the input always being under at <code class="language-plaintext highlighter-rouge">./input</code> and some logging for debugging purposes, which I found to be extremely helpful last year. I’ve gone a bit further too and have a small CLI that downloads the days input automatically: <code class="language-plaintext highlighter-rouge">aoc-utils download</code> after a puzzle is released and <code class="language-plaintext highlighter-rouge">./input</code> is set up and ready to go as well!</p>

<p>The last part to all of this is a set of tests. I like to start off with tests against the example input and the known solution to those samples as well as tests against my final solution so that I can refactor my code and ensure the solution stays the same.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">XCTest</span>
<span class="kd">@testable</span> <span class="kd">import</span> <span class="n">dayXX</span>

<span class="k">let</span> <span class="nv">testInput</span> <span class="o">=</span> <span class="s">"""
"""</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="nv">dayXXTests</span><span class="p">:</span> <span class="kt">XCTestCase</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">testPartOneExample</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">parsedOutput</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">()</span><span class="o">.</span><span class="nf">parseString</span><span class="p">(</span><span class="n">testInput</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Challenge</span><span class="o">.</span><span class="kt">PartOne</span><span class="p">()</span><span class="o">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">parsedOutput</span><span class="p">)</span>

        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">testPartTwoExample</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">parsedOutput</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">()</span><span class="o">.</span><span class="nf">parseString</span><span class="p">(</span><span class="n">testInput</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Challenge</span><span class="o">.</span><span class="kt">PartTwo</span><span class="p">()</span><span class="o">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">parsedOutput</span><span class="p">)</span>

        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">testPartOneRealInput</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">parsedOutput</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">()</span><span class="o">.</span><span class="nf">parseFile</span><span class="p">(</span><span class="s">"input"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Challenge</span><span class="o">.</span><span class="kt">PartOne</span><span class="p">()</span><span class="o">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">parsedOutput</span><span class="p">)</span>

        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">testPartTwoRealInput</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">parsedOutput</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">()</span><span class="o">.</span><span class="nf">parseFile</span><span class="p">(</span><span class="s">"input"</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">solution</span> <span class="o">=</span> <span class="kt">Challenge</span><span class="o">.</span><span class="kt">PartTwo</span><span class="p">()</span><span class="o">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">parsedOutput</span><span class="p">)</span>

        <span class="kt">XCTAssertEqual</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, once everything is in place and I’ve got a solution setup I can run <code class="language-plaintext highlighter-rouge">swift test</code> and make sure my solution is correct, and <code class="language-plaintext highlighter-rouge">swift run dayXX part-one</code> / <code class="language-plaintext highlighter-rouge">swift run dayXX part-two</code> to get my solution to put in on the site.</p>

<p>With that all in place, let’s dive into the first puzzle which’ll give us a nice warm up for the season!</p>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>Find the Elf carrying the most Calories. How many total Calories are that Elf carrying?</p>
</blockquote>

<p>We’ll take a fairly common and slightly naive approach today. There is a way to solve this without building an array of every elf’s calories, instead you just keep track of the highest seen calorie count and the calorie count for the current elf, but that “clever” solution isn’t what I’m after and doesn’t lend itself to showing off some of the language features around iterators.</p>

<p>Looking at our input, we can see each elf’s calorie list is separated by a blank line, and each elf has one or more lines of integer numbers that’ll we will need to sum up in order to find that elf’s total number of calories carried. We can start by splitting the input into an <a href="#annotation-3" class="annotation-trigger -gray">array of strings</a>
<span id="annotation-3" class="annotation">In Swift’s type annotations: <code class="language-plaintext highlighter-rouge">[String]</code>, although in reality what we’ll get is actually a <code class="language-plaintext highlighter-rouge">[Substring]</code> where <code class="language-plaintext highlighter-rouge">Substring</code> is actually a <a href="https://developer.apple.com/documentation/swift/substring">reference</a> to the slice of our original string which contains our split out components. A <code class="language-plaintext highlighter-rouge">Substring</code> is intended to be short-lived, so we normally wouldn’t want to pass it around without copying the contents to a separate <code class="language-plaintext highlighter-rouge">String</code> however today we’ll be fairly quickly converting the <code class="language-plaintext highlighter-rouge">Substring</code> into an <code class="language-plaintext highlighter-rouge">Int</code> so it shouldn’t matter too much.</span>
. From there we should be able to iterate over this array, and split each string into even smaller strings representing each item’s calories. From there it’ll be a matter of converting the stringified numbers to Swift <code class="language-plaintext highlighter-rouge">Int</code>s and summing them up.</p>

<p>Assuming <code class="language-plaintext highlighter-rouge">input</code> is our string representing our puzzle’s … well, input, we can use the <a href="https://developer.apple.com/documentation/swift/string/split%28separator:maxsplits:omittingemptysubsequences:%29"><code class="language-plaintext highlighter-rouge">split(separator:)</code></a> function to split on two newlines (<code class="language-plaintext highlighter-rouge">\n\n</code>):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Now that we’ve got each elf’s calories separated out we can focus on a single elf at a time. Again we’ll need to split, but only on a single new line this time, and then we’ll convert each element in that split to an integer and sum them up. Swift’s iterators make this fairly easy to do in one go using <a href="https://developer.apple.com/documentation/swift/array/reduce%28_:_:%29"><code class="language-plaintext highlighter-rouge">reduce(_:_:)</code></a>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">parseElf</span><span class="p">(</span><span class="n">_</span> <span class="nv">rawLinesOfCalories</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">rawLinesOfCalories</span>
        <span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">memo</span><span class="p">,</span> <span class="n">caloriesLine</span> <span class="k">in</span> <span class="n">memo</span> <span class="o">+</span> <span class="p">(</span><span class="kt">Int</span><span class="p">(</span><span class="n">caloriesLine</span><span class="p">)</span> <span class="p">??</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The biggest thing with this process is that parsing our string into an integer with <code class="language-plaintext highlighter-rouge">Int(_: String) -&gt; Int?</code> returns an <a href="https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID452">Optional</a>. We could, for the sake of this challenge since we know the input is well formed, force unwrap it with <code class="language-plaintext highlighter-rouge">Int(caloriesLine)!</code> but we could also provide a fallback just in case, using the <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID72">nil-coalescing operator <code class="language-plaintext highlighter-rouge">??</code></a>. Note that we’re putting this parsing into a separate function as it’ll make the next bit a little easier.</p>

<p>Next, we can map over our split up input, calling this new <code class="language-plaintext highlighter-rouge">paseElf(_:)</code> function and have an array that’ll give us the answer to both parts. I’m going to go a step further and shove them into a small container to make debugging easier and to get our first taste of <code class="language-plaintext highlighter-rouge">typealias</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">ElfToCalories</span> <span class="o">=</span> <span class="p">(</span><span class="nv">elf</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">calories</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">parseString</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">ElfToCalories</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="nv">separator</span><span class="p">:</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">parseElf</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span>
        <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">calories</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">let</span> <span class="nv">elfsTuple</span> <span class="o">=</span> <span class="p">(</span><span class="nv">elf</span><span class="p">:</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">calories</span><span class="p">:</span> <span class="n">calories</span><span class="p">)</span>

            <span class="kt">Logger</span><span class="o">.</span><span class="n">parsing</span><span class="o">.</span><span class="nf">debug</span><span class="p">(</span><span class="s">"Elf </span><span class="se">\(</span><span class="n">elfsTuple</span><span class="o">.</span><span class="n">elf</span><span class="se">)</span><span class="s">: </span><span class="se">\(</span><span class="n">elfsTuple</span><span class="o">.</span><span class="n">calories</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">elfsTuple</span>
        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Breaking this down a little bit, we can see that we’re defining a <code class="language-plaintext highlighter-rouge">typealias</code> for a named-element tuple containing the elf’s number in our input (we’ll 1-index this to make it easier to debug against the problems example) and their calories. Next we do our existing split on the double new lines and we map each element into an integer. At the point that we call <code class="language-plaintext highlighter-rouge">.enumerated()</code>, we’ll have an array of integers (<code class="language-plaintext highlighter-rouge">[Int]</code>). <code class="language-plaintext highlighter-rouge">.enumerated()</code> is the magic that lets us get the elf’s index within the array, it transforms our array of integers into an array of tuples, where the first element of each tuple is the index and the second is the original value:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">elfCalories</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">elfCalories</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="c1">// Equivalent to: [(0, 50), (1, 42), (2, 38), (3, 9)]</span>
</code></pre></div></div>

<p>Finally we map over this one last time to convert our 0-indexed into 1-indexing and our <code class="language-plaintext highlighter-rouge">ElfToCalories</code> tuple and to log out some helpful messages. Finally we’ve gotten our input parsed into a helpful data structure and we’re able to get on with the challenge. We need to find the elf that is carrying the most amount of calories, which we can do using <a href="https://developer.apple.com/documentation/swift/array/max%28by:%29"><code class="language-plaintext highlighter-rouge">max(by:)</code></a>. This returns an optional but we know that we’ll have a max so we’ll take the shortcut and force unwrap it. Since we’re working with our named-element tuple, we can pull out the calories to get our solution:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">solve</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="p">[</span><span class="kt">ElfToCalories</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span>
        <span class="o">.</span><span class="n">max</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">in</span> <span class="n">a</span><span class="o">.</span><span class="n">calories</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">calories</span> <span class="p">}</span><span class="o">!</span>
        <span class="o">.</span><span class="n">calories</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>Find the top three Elves carrying the most Calories. How many Calories are those Elves carrying in total?</p>
</blockquote>

<p>We can stick with the same parsing for part one but instead of using <code class="language-plaintext highlighter-rouge">max(by:)</code>, we’ll have to find <em>three</em> elves and add their calories together. Thankfully Swift has <a href="https://developer.apple.com/documentation/swift/array/sorted%28by:%29"><code class="language-plaintext highlighter-rouge">sorted(by:)</code></a> and <a href="https://developer.apple.com/documentation/swift/array/prefix%28_:%29"><code class="language-plaintext highlighter-rouge">prefix(_:)</code></a> which we can use to first sort our array so that the highest calorie elves are at the front, and then we can take the first 3 elves. From there we can use <code class="language-plaintext highlighter-rouge">reduce(_:_:)</code> again to sum up their combined calories for our solution!</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">solve</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="p">[</span><span class="kt">ElfToCalories</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span>
        <span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">in</span> <span class="n">a</span><span class="o">.</span><span class="n">calories</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">calories</span> <span class="p">}</span>
        <span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">memo</span><span class="p">,</span> <span class="n">elf</span> <span class="k">in</span> <span class="n">memo</span> <span class="o">+</span> <span class="n">elf</span><span class="o">.</span><span class="n">calories</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And that’s it, we’ve survived day 1, see you tomorrow!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/02/AoC-2022-Day-02.html">Day 02</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="swift" /><category term="aoc" /><category term="puzzles" /><summary type="html"><![CDATA[This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.]]></summary></entry><entry><title type="html">Advent of Code 2022 Anthology</title><link href="https://joshisa.ninja/aoc/2022/12/01/aoc-2022.html" rel="alternate" type="text/html" title="Advent of Code 2022 Anthology" /><published>2022-12-01T01:00:00+00:00</published><updated>2022-12-01T01:00:00+00:00</updated><id>https://joshisa.ninja/aoc/2022/12/01/aoc-2022</id><content type="html" xml:base="https://joshisa.ninja/aoc/2022/12/01/aoc-2022.html"><![CDATA[<p>Welcome back to the end of another year and that means another season of <a href="adventofcode.com/">Advent of Code</a>!</p>

<p>Last year was the first time that I actively participated and I chose to solve the challenges using OCaml to better familiarize myself with the language. This year I decided that, as much as I enjoy OCaml, I’ve been doing enough Swift for some side projects that I’d love to learn some of the language’s features better.</p>

<p>While I didn’t do write up’s last year, I’ve set the challenge to put together a small write up of my solutions for this year as I work through them with the hopes of practicing my technical writing skills. Additionally, while there is some joy in trying to solve the problems the fastest and most golfed, clever code, I’m also looking to strike a balance of maintainable and readable code and exploring some more features of the language, so every day’s write up may not be super advanced OR optimal.</p>

<p>This years theme is: The elves stage a tropical expedition, in the name of the reindeer’s magical energy supply, to find 50 star fruit.</p>

<h2 id="days">Days</h2>

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/AoC-2022-Day-01.html">AoC 2022 Day 01 - The elves count calories, we do an intro</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/02/AoC-2022-Day-02.html">AoC 2022 Day 02 - The elves play Rock, Paper, Scissors, we win</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/03/AoC-2022-Day-03.html">AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/04/AoC-2022-Day-04.html">AoC 2022 Day 04 - The elves clean up base camp, we free up resources</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/05/AoC-2022-Day-05.html">AoC 2022 Day 05 - The elves rearrange some crates on a boat, we play alphabet blocks with the crates</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/06/AoC-2022-Day-06.html">AoC 2022 Day 06 - The elves recieve an email, we decode it</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/07/AoC-2022-Day-07.html">AoC 2022 Day 07 - The elves give you an outdated device with not enough disk space, we delete the filesystem</a></p>
  </li>
  <li>
    <p><a href="/aoc/2022/12/08/AoC-2022-Day-08.html">AoC 2022 Day 08 - The elves want a hidden treehouse with a great view, we’re their realtor</a></p>
  </li>
</ul>]]></content><author><name></name></author><category term="aoc" /><category term="aoc" /><category term="swift" /><category term="puzzles" /><summary type="html"><![CDATA[Welcome back to the end of another year and that means another season of Advent of Code!]]></summary></entry><entry><title type="html">SvelteKit &amp;amp; Cloudflare Durable Object Websockets</title><link href="https://joshisa.ninja/2022/05/18/sveltekit-cloudflare-durable-object-websockets.html" rel="alternate" type="text/html" title="SvelteKit &amp;amp; Cloudflare Durable Object Websockets" /><published>2022-05-18T00:00:00+00:00</published><updated>2022-05-18T00:00:00+00:00</updated><id>https://joshisa.ninja/2022/05/18/sveltekit-cloudflare-durable-object-websockets</id><content type="html" xml:base="https://joshisa.ninja/2022/05/18/sveltekit-cloudflare-durable-object-websockets.html"><![CDATA[<div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<p>I’m always eyeing light-weight setups to build out little personal tools that let me have a combo of static or Svelte based frontends and little server side APIs for persistence and the likes. Historically this took the shape of Ruby/Roda/SQLite backends with a Vite.js/Svelte frontend setup, but recently I decided to give SvelteKit a go since it checks all the boxes and requires minimal setup. I still need somewhere to painlessly host these SvelteKit based projects as I don’t feel like spinning up a VPS and my go to static host, GitHub Pages, doesn’t allow me to run a small back-end server. Cloudflare’s been making some big splashes in this area as of late, however, so I decided to give them a go and see what’s what with thier Worker and Pages platforms.</p>

<p>Today, I’ll just be focusing on some friction I hit when trying to use a websocket to a Cloudflare Durable Object from within a SvelteKit Endpoint hosted with Cloudflare Page Functions, and my exploration of a crude solution to keep the ergonomics of Endpoints while accomplishing my goal of establishing this websocket connection.</p>
<h3 id="intros">Intros</h3>
<p>Pages are Cloudflares static hosting solution that entered General Availablility in April of 2021, and back in November of 2021 they announced a new feature to Pages called <a href="https://blog.cloudflare.com/cloudflare-pages-goes-full-stack/">“Functions”</a> which are slightly specialized versions of <a href="#annotation-3" class="annotation-trigger -gray">Cloudflare Workers</a>
<span id="annotation-3" class="annotation">Cloudflare Workers being their stateless, “serverless” solution, running your code on a per-request basis in an isolated V8 environment.</span>
 that can be deployed alongside your Pages project to provide a full API or even do server side rendering or other tasks. While Page Functions are in <a href="https://developers.cloudflare.com/pages/platform/functions/">beta still</a>, they’re already powerful and fun to play with and open a ton of doors for progressively enhancing existing static sites with more dynamic and server side functionality, due to Pages’ support for easily publishing existing frameworks such as my beloved Jekyll.</p>

<p>While Page Functions, like the Workers they use behind the scenes, are stateless, Cloudflare has also released into General Availability a feature to Workers that they call <a href="https://blog.cloudflare.com/durable-objects-ga/">“Durable Objects”</a>. Durable Objects are essentially another form of specialized Workers that have disk and cache backed storage for persistence and aim to help solve issues around state keeping in the distributed environment that Worker’s run in.</p>

<p>Finally, SvelteKit is the official Svelte based setup for building static, server side rendered, and single page applications. It’s similar in concept to Next.js/Nuxt.js but using Svelte instead. SvelteKit has two parts: the Svelte stuff, which can be server side rendered, or prerendered into a static site, and server side <a href="https://kit.svelte.dev/docs/routing#endpoints">“Endpoints”</a> which write and route very similar to Page Functions and give you the ability to fairly painlessly build out APIs and other back-end functionality that ties in with the rest of your Svelte project seamlessly. The other neat thing about SvelteKit is that it already has an “adaptor” to build and deploy to Cloudflare Pages, including the ability to convert it’s endpoints into Page Functions!</p>

<h3 id="and-the-websockets">And the WebSockets?</h3>
<p>One neat thing with Durable Objects is that a single instance can hold onto multiple websocket connections, a feature that the demonstrate with their <a href="https://github.com/cloudflare/workers-chat-demo">chat demo</a>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Our DurableObject</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">Room</span> <span class="p">{</span>
  <span class="nl">sockets</span><span class="p">:</span> <span class="nx">WebSocket</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">state</span><span class="p">:</span> <span class="nx">DurableObjectState</span><span class="p">,</span> <span class="k">public</span> <span class="nx">env</span><span class="p">:</span> <span class="nx">Env</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">async</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocketPair</span><span class="p">()</span>
		<span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">accept</span><span class="p">()</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">sockets</span> <span class="o">=</span> <span class="p">[...</span><span class="k">this</span><span class="p">.</span><span class="nx">sockets</span><span class="p">,</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">onMessage</span><span class="p">(({</span> <span class="nx">data</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">sockets</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">socket</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">socket</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">new connection!</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="na">webSocket</span><span class="p">:</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To use this feature from a regular Worker, you pretty much just pass through the request from the client to the Durable Object. Since Page Functions are just Workers wrapped with a little more structure, we can use the same concept for them in our Pages project just within a <code class="language-plaintext highlighter-rouge">onRequestXYZ</code> handler:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// functions/api/rooms/[id]/[[restUrl]].ts</span>
<span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">onRequestGet</span><span class="p">({</span> <span class="nx">request</span><span class="p">,</span> <span class="nx">env</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URL</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">url</span><span class="p">)</span>

  <span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="nx">idFromName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">roomObject</span> <span class="o">=</span> <span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">roomObject</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">.</span><span class="nx">pathname</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Obviously you’d want to put in some path handling, validation and error handling and removing dead connections from <code class="language-plaintext highlighter-rouge">sockets</code> to both sides, but this is the general approach for setting up this feature and getting multiple clients all coordinating through websockets. While nothing new and groundbreaking, this is by far the easiest and lowest entry barrier into a setup like this, and I’ve been pretty happy with the developer experience even with all the rough edges a lot of this still has in Cloudflare.</p>

<h3 id="sveltekit">SvelteKit</h3>
<p>SvelteKit endpoints look and write pretty similar to Page Functions, and as stated above they can be deployed to Cloudflare Page Functions with ease. Unfortunately, I’m new to using SvelteKit (and it’s pre-1.0 still so stuff is in flux just like with half of the Cloudflare features we’re using here already) so I had a bit of a learning experience to figure out how to ~best work with~ hack around with stuff to get DO’s inside of SvelteKit endpoints working.</p>

<p>Let’s take a stab at converting the above Page Function into an endpoint:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/routes/api/rooms/[id]/[...restUrl].ts</span>
<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">RequestHandler</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./[...restUrl].d</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="kd">get</span><span class="p">:</span> <span class="nx">RequestHandler</span> <span class="o">=</span> <span class="k">async</span> <span class="p">({</span>
  <span class="nx">params</span><span class="p">,</span>
  <span class="nx">platform</span><span class="p">,</span>
  <span class="nx">request</span><span class="p">,</span>
<span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">roomId</span> <span class="o">=</span> <span class="nx">platform</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="nx">idFromName</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">room</span> <span class="o">=</span> <span class="nx">platform</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">roomId</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">room</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="mi">404</span> <span class="p">}</span>

  <span class="k">return</span> <span class="nx">room</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">restUrl</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Unsurprisingly, it looks pretty dang similar, but it doesn’t work. The first problem is that Endpoints don’t return a <code class="language-plaintext highlighter-rouge">Response</code> object, like Page Functions do; instead they have a simplified type of <code class="language-plaintext highlighter-rouge">{ status, headers, body }</code> which you can return. This is a bit of a problem, because as you might have guessed already, <code class="language-plaintext highlighter-rouge">room.fetch()</code> is returning a <code class="language-plaintext highlighter-rouge">Response</code> object. Let’s try and change our endpoint to account for this difference and see where it gets us:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">room</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">restUrl</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">status</span><span class="p">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">headers</span><span class="p">,</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>This works for non-websocket requests, but as soon as you try to open a websocket to the DO you hit this fun error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RangeError: Responses may only be constructed with status codes in the range 200 to 599, inclusive.
</code></pre></div></div>

<p>Wut. I get that frameworks like SvelteKit try to make things easier but come on, HTTP is a lot more flexible than 200..599 status codes and the classic GET/POST/PUT/PATCH/DELETE/HEAD methods. Anyways.</p>

<p>Let’s take a step back for a second and poke around the SvelteKit docs. In here, we’ll find this little thing called <a href="https://kit.svelte.dev/docs/hooks#handle">“Hooks”</a> and specifically, the <code class="language-plaintext highlighter-rouge">handle</code> hook. This is a function that takes in a <code class="language-plaintext highlighter-rouge">Request</code> and is expected to return a <code class="language-plaintext highlighter-rouge">Response</code> object and is called for nearly every request that hits the server. Ah-HA! Just what we need, the ability to return a <code class="language-plaintext highlighter-rouge">Response</code> object directly. Let’s make a hook that does this:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/hooks.ts</span>
<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">Handle</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@sveltejs/kit</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">handle</span><span class="p">:</span> <span class="nx">Handle</span> <span class="o">=</span> <span class="k">async</span> <span class="p">({</span> <span class="nx">event</span><span class="p">,</span> <span class="nx">resolve</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span>
    <span class="nx">request</span><span class="p">,</span>
    <span class="na">url</span><span class="p">:</span> <span class="p">{</span> <span class="nx">pathname</span> <span class="p">},</span>
    <span class="nx">params</span><span class="p">,</span>
    <span class="nx">platform</span><span class="p">,</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">pathname</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="dl">"</span><span class="s2">/websocket</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">roomId</span> <span class="o">=</span> <span class="nx">platform</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="nx">idFromName</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">room</span> <span class="o">=</span> <span class="nx">platform</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">roomId</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">room</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="dl">"</span><span class="s2">Not found</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="mi">404</span> <span class="p">})</span>

    <span class="k">return</span> <span class="nx">room</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">restUrl</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a dirty and naive attempt, we’re just expecting the url to end with <code class="language-plaintext highlighter-rouge">/websocket</code> and that there is a <code class="language-plaintext highlighter-rouge">params.id</code> and <code class="language-plaintext highlighter-rouge">params.restUrl</code> if we’re going to return the raw response from the DO. But sure enough, it’ll work! I’d clean this up and add better checks to ensure that we’re on the right route before attempting to interact with the DO, but the principle is there.</p>

<h3 id="on-ergonomics">On Ergonomics</h3>
<p>So we’ve got our SvelteKit app, hosted on Cloudflare Pages and using Page Functions for the SvelteKit endpoints, responding to a websocket request and passing it through to our Durable Object which’ll do all the heavy lifting to coordinate all connected clients. But it’s using a naive, inflexible and not really ergonomic solution right now. For starters, it misses out on the routing that our endpoint gave us, so we have to do a bunch of path checking ourselves to make sure that we’re handling the correct request. It also disconnects the logic from the rest of the relevant code, as it lives in <code class="language-plaintext highlighter-rouge">src/hooks.ts</code> whereas our other logic for talking with these DO is located in the <code class="language-plaintext highlighter-rouge">src/routes/api/rooms/</code> directory.</p>

<p>This is where my dirty, no good, hack solution comes in. I wanted to be able to use and return the <code class="language-plaintext highlighter-rouge">room.fetch()</code> calls directly from my endpoints rather than having to stuff them under a hook. The best way to do this, so far as I can tell right now, is to stuff things into <a href="https://kit.svelte.dev/docs/types#app-locals"><code class="language-plaintext highlighter-rouge">locals</code></a> from the request event that endpoints receive, and having a hook that’ll return a response that is stuffed into there. It’s <strong>not ideal</strong> and I would not recommend this for any production app, but it does work. Let’s take a look at the hook for this:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/hooks.ts</span>
<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">Handle</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@sveltejs/kit</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">handle</span><span class="p">:</span> <span class="nx">Handle</span> <span class="o">=</span> <span class="k">async</span> <span class="p">({</span> <span class="nx">event</span><span class="p">,</span> <span class="nx">resolve</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">locals</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">event</span>

  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">locals</span><span class="p">.</span><span class="nx">wsResponse</span><span class="p">)</span> <span class="k">return</span> <span class="nx">locals</span><span class="p">.</span><span class="nx">wsResponse</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And how it’s used within the endpoint:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/routes/api/rooms/[id]/[...restUrl].ts</span>
<span class="k">import</span> <span class="kd">type</span> <span class="p">{</span> <span class="nx">RequestHandler</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./[...restUrl].d</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="kd">get</span><span class="p">:</span> <span class="nx">RequestHandler</span> <span class="o">=</span> <span class="k">async</span> <span class="p">({</span>
  <span class="nx">params</span><span class="p">,</span>
  <span class="nx">platform</span><span class="p">,</span>
  <span class="nx">request</span><span class="p">,</span>
  <span class="nx">locals</span><span class="p">,</span>
<span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">roomId</span> <span class="o">=</span> <span class="nx">platform</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="nx">idFromName</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">room</span> <span class="o">=</span> <span class="nx">platform</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">roomId</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">room</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="mi">404</span> <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">room</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">restUrl</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>

  <span class="c1">// Hack to allow this endpoint to handle websockets from the DO</span>
  <span class="c1">// The hook will return the contents of local.wsResponse</span>
  <span class="c1">// if present since endpoints can't return a Response object and</span>
  <span class="c1">// can't return status codes under 200 (or over 599).</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">101</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">locals</span><span class="p">.</span><span class="nx">wsResponse</span> <span class="o">=</span> <span class="nx">res</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="mi">200</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">status</span><span class="p">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">headers</span><span class="p">,</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">body</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Told you it was a hack. But it does work, helps keep the logic all contained in one spot and gives us the ergonomics of endpoints with only a minor inconvenience. It’d probably take this further and bundle it up into a little helper function to hide the implementation details and to help avoid abuse, but the general principle would be the same.</p>

<p>After getting this figured out, things have been pretty smooth sailing overall. I hope that SvelteKit gains the ability to return a raw Reponse from an endpoint in the future, or at least enough support to allow one to <a href="https://github.com/sveltejs/kit/issues/1491">handle websockets</a> a little better so that this hack isn’t necessary. I also wish Durable Objects were creatable from Pages’ projects, or on their own without needing a <a href="#annotation-4" class="annotation-trigger -gray">no-op Worker</a>
<span id="annotation-4" class="annotation">I’ll try to write about this experience on a later date once I’ve gotten some more experience with this setup.</span>
, as currently I’ve got a separate setup to publish the DO’s that my SvelteKit project is using. This separate setup even has it’s own deploy step that isn’t handled by the Pages deploy. Additionally, I hope that Page Functions get logging <em>soon</em> and that they stop requiring Git integration to get Page Functions uploaded, but for a beta they’re pretty powerful already and I’m excited to build some tools on top of this setup.</p>]]></content><author><name></name></author><category term="svelte" /><category term="sveltekit" /><category term="cloudflare" /><category term="cloudflare-pages" /><category term="cloudflare-durable-objects" /><summary type="html"><![CDATA[Hacking my way through tying together SvelteKit Endpoints and Websockets to Cloudflare Durable Objects.]]></summary></entry></feed>