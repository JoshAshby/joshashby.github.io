<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="apple-mobile-web-app-status-bar-style" content="#1f2937">
  <meta name="theme-color" content="#1f2937" />

  <title>AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf - Ashby's Hideout</title>
  <meta name="description" content="">

  <link type="application/atom+xml" rel="alternate" href="https://joshisa.ninja/feed.xml" title="Ashby's Hideout" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf | Ashby’s Hideout</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too." />
<meta property="og:description" content="This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too." />
<link rel="canonical" href="https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03.html" />
<meta property="og:url" content="https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03.html" />
<meta property="og:site_name" content="Ashby’s Hideout" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-12-03T23:59:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-12-03T23:59:00+00:00","datePublished":"2022-12-03T23:59:00+00:00","description":"This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by clicking or tapping on them Annotations might have their own annotationsSuch as this one! inside of them too.","headline":"AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf","mainEntityOfPage":{"@type":"WebPage","@id":"https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03.html"},"url":"https://joshisa.ninja/aoc/2022/12/03/AoC-2022-Day-03.html"}</script>
<!-- End Jekyll SEO tag -->


  <link rel="stylesheet" href="/vite/assets/ashby.3d2ee3e1.css" media="screen"/>

  <style>
  
  </style>
</head>

<body>
  <div id="master-chief">
    <section id="main-sidebar">
      <nav class="sidebar-nav">
        <h2><a href="/">Ashby's Hideout</a></h2>

        <div id="nav-links" class="expandable">
          <ul class="nav-list">
            <li class="nav-item"><a href="/posts/">Posts</a></li>
            <li class="nav-item"><a href="/photos/">Photos</a></li>
            <li class="nav-item"><a href="/projects/">Projects</a></li>
            <li class="nav-item"><a href="/resume/">Resume</a></li>

            
          </ul>
        </div>

        <div class="hamburger-bun">
          <button class="nav-item" data-behavior="toggle-hidden" data-target="#nav-links">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
          </button>
        </div>
      </nav>
    </section>

    <main>
      <article class="default-post">
  <header id="page-header">
  <div class="flex flex-col flex-grow space-y-4">
    <h1 class="mb-2">AoC 2022 Day 03 - The elves redo one particularly incompetent elf’s job, we fire the elf</h1>

    <div class="flex flex-row space-x-2 items-center">
      <div class="flex flex-col md:flex-row items-center space-x-1 text-sm leading-5 text-gray-500 dark:text-gray-400 sm:mr-6 font-sans">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
        <time class="font-mono text-sm whitespace-nowrap" datetime="2022-12-03">Dec 03, 2022</time>
      </div>

      

      <div class="flex flex-row flex-wrap space-x-1 items-center justify-end flex-grow">
        
          <a href="/tags#swift" name="swift"><span class="tag">swift</span></a>

        
          <a href="/tags#aoc" name="aoc"><span class="tag">aoc</span></a>

        
          <a href="/tags#puzzles" name="puzzles"><span class="tag">puzzles</span></a>

        
      </div>
    </div>
  </div>
</header>


  <div>
  <em>
  This post contains inline annotations/footnotes to help add context, helpful tips or expand upon a tangent in the text. Expand them by <a href="#annotation-1" class="annotation-trigger -gray">clicking or tapping on them</a>
<span id="annotation-1" class="annotation">Annotations might have their own <a href="#annotation-2" class="annotation-trigger -red">annotations</a><span id="annotation-2" class="annotation">Such as this one!</span> inside of them too.</span>

  </em>
</div>

<h2 id="part-one">Part One</h2>
<blockquote>
  <p>Find the item type that appears in both compartments of each rucksack. What is the sum of the priorities of those item types?</p>
</blockquote>

<p>So we’ve got an elf’s rucksack per line in our input. Each rucksack has two compartments and there is an item that is present in both compartments that we need to identify. Basically, we need to do an intersection between the two compartments and then convert the character representing the item into a “priority” number.</p>

<p>Unfortunately Swift doesn’t have a built-in intersection for Arrays, but does have intersections for Sets, so let’s parse our input into those. As we did for yesterday, let’s make a little container to hold our rucksack contents to make our code a little easier to read:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Rucksack</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">compartmentA</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">Character</span><span class="o">&gt;</span>
    <span class="k">let</span> <span class="nv">compartmentB</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">Character</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As stated above, we’ll benefit from using Sets, so the first part reduces down to something like the following, using our new <code class="language-plaintext highlighter-rouge">Rucksack</code> struct:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">itemInBothCompartments</span> <span class="o">=</span> <span class="n">rucksack</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">rucksack</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span>
</code></pre></div></div>

<p>Before we finish that thought, though, let’s finish parsing an elf’s line. Now that we’ve got our container struct we need to do two things: split a line from our input in half and then convert each half into a <code class="language-plaintext highlighter-rouge">Set</code> of <code class="language-plaintext highlighter-rouge">Characters</code>. Thankfully we can use swifts <code class="language-plaintext highlighter-rouge">Array#prefix()</code> and <code class="language-plaintext highlighter-rouge">Array#suffix()</code> methods to get the first half and the second half of the line in a fairly easy to read way. We can also map over the resulting arrays and initialize a <code class="language-plaintext highlighter-rouge">Character</code> before we initialize our <code class="language-plaintext highlighter-rouge">Set</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">parseLine</span><span class="p">(</span><span class="n">_</span> <span class="nv">line</span><span class="p">:</span> <span class="kt">Substring</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Rucksack</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">halfLength</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">count</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">let</span> <span class="nv">compartmentAArray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="n">halfLength</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Character</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">compartmentBArray</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="nf">suffix</span><span class="p">(</span><span class="n">halfLength</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Character</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>

    <span class="k">return</span> <span class="o">.</span><span class="nf">init</span><span class="p">(</span>
        <span class="nv">compartmentA</span><span class="p">:</span> <span class="kt">Set</span><span class="p">(</span><span class="n">compartmentAArray</span><span class="p">),</span>
        <span class="nv">compartmentB</span><span class="p">:</span> <span class="kt">Set</span><span class="p">(</span><span class="n">compartmentBArray</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this, one last part of the puzzle remains: Once we have the intersection, we have a character that needs to be mapped to a “priority” number using the following rules:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">a</code> through <code class="language-plaintext highlighter-rouge">z</code> maps to 1 - 26</li>
  <li><code class="language-plaintext highlighter-rouge">A</code> through <code class="language-plaintext highlighter-rouge">Z</code> maps to 27 - 52</li>
</ul>

<p>If you’re familiar with the ASCII representations for a-z and A-Z you’ll immediately see that even if we take the ASCII number value for our characters, <code class="language-plaintext highlighter-rouge">A</code> - <code class="language-plaintext highlighter-rouge">Z</code> maps to a lower range (65-90) than <code class="language-plaintext highlighter-rouge">a</code> - <code class="language-plaintext highlighter-rouge">z</code> (97-122) and neither of those align with our 1-52 range of values! We’ll have to subtract a fixed value, but we’ll also have to have two different fixed values, depending on if the character is upper-case or lower. Let’s remap <code class="language-plaintext highlighter-rouge">A</code>-<code class="language-plaintext highlighter-rouge">Z</code> first:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">remapCharToPriority</span><span class="p">(</span><span class="n">_</span> <span class="nv">char</span><span class="p">:</span> <span class="kt">Character</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">rawAsciiValue</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">asciiValue</span><span class="o">!</span><span class="p">)</span>

    <span class="c1">// A-Z have priority of 27 - 52</span>
    <span class="k">return</span> <span class="n">rawAsciiValue</span> <span class="o">-</span> <span class="mi">38</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A few things to note here: <code class="language-plaintext highlighter-rouge">Character#asciiValue</code> returns an optional. We’re going to force unwrap the result since we are trusting that our input falls only within ASCII values. You’d probably want to add some additional sanity checks here for real-world problems but since we know that our input is going to be well formed, we’ll get away with this. Secondly, <code class="language-plaintext highlighter-rouge">Character#asciiValue</code> returns an <code class="language-plaintext highlighter-rouge">UInt8</code> instead of an <code class="language-plaintext highlighter-rouge">Int</code> which could be fine, but we’ll overflow <code class="language-plaintext highlighter-rouge">UInt8</code>, which can only store from 0 to 255, once we start adding together priorities from other elves’ rucksacks. To get around this we convert the <code class="language-plaintext highlighter-rouge">UInt8</code> to an <code class="language-plaintext highlighter-rouge">Int</code> which has a far wider range that it can store (which means we don’t have to worry about this conversion going south at any point too). Finally, we subtract 38 which means that <code class="language-plaintext highlighter-rouge">A</code> will map to <code class="language-plaintext highlighter-rouge">27</code> (<code class="language-plaintext highlighter-rouge">65 - 27 = 38</code>) and <code class="language-plaintext highlighter-rouge">Z</code> to <code class="language-plaintext highlighter-rouge">52</code> as we expect.</p>

<p>We’ve got one case to handle here, however: <code class="language-plaintext highlighter-rouge">a</code> which is <code class="language-plaintext highlighter-rouge">97</code> in ASCII will currently map to <code class="language-plaintext highlighter-rouge">59</code> which isn’t what we want. We need to add an if branch for when the ASCII value is 97 or higher and return the ASCII value subtracting <code class="language-plaintext highlighter-rouge">96</code> in order to correctly map the lower-case characters:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">remapCharToPriority</span><span class="p">(</span><span class="n">_</span> <span class="nv">char</span><span class="p">:</span> <span class="kt">Character</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">rawAsciiValue</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">asciiValue</span><span class="o">!</span><span class="p">)</span>

    <span class="c1">// a-z have priority of 1 - 26</span>
    <span class="k">if</span> <span class="n">rawAsciiValue</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rawAsciiValue</span> <span class="o">-</span> <span class="mi">96</span>
    <span class="p">}</span>

    <span class="c1">// A-Z have priority of 27 - 52</span>
    <span class="k">return</span> <span class="n">rawAsciiValue</span> <span class="o">-</span> <span class="mi">38</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that we’ve got all we need to solve this part of the puzzle:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rucksacks</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="o">!</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">remapCharToPriority</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>For each rucksack, we find the item that exists in both compartments. We can force unwrap this because, again, we know that our input will have a duplicate per line but we’d want some better error handling for real-life applications. Then we remap each duplicate item into its priority and finally sum it all together.</p>

<h2 id="part-two">Part Two</h2>
<blockquote>
  <p>Find the item type that corresponds to the badges of each three-Elf group. What is the sum of the priorities of those item types?</p>
</blockquote>

<p>Now, instead of finding the duplicated item across a single rucksack’s compartments, we’re looking for a duplicated item across three elfs’ rucksacks. It turns out that we can keep our mapping logic the same, and our only changes will be how we apply intersections across the rucksacks. The first thing we can change is unioning the two compartments of each rucksack together since we don’t care about duplicates for a single elf anymore:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rucksacks</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">union</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>The next thing we need to do is divide the rucksacks into groups of three. Unfortunately swift doesn’t have a built in <code class="language-plaintext highlighter-rouge">cons</code>, <code class="language-plaintext highlighter-rouge">pairs</code>, or <code class="language-plaintext highlighter-rouge">slicesOf</code> function for any data structure, so we’ll have to make our own. We’ll do this using an extension onto Array so let’s write our signature that we’re aiming for first:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Array</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">chunked</span><span class="p">(</span><span class="n">into</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Element</span><span class="p">]]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="c1">// something ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Thankfully the swift standard library includes a neat little <a href="https://developer.apple.com/documentation/swift/stride%28from:to:by:%29"><code class="language-plaintext highlighter-rouge">stride</code></a> function:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">stride</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">from</span> <span class="nv">start</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span>
    <span class="n">to</span> <span class="nv">end</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span>
    <span class="n">by</span> <span class="nv">stride</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Stride</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">StrideTo</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">T</span> <span class="p">:</span> <span class="kt">Strideable</span>
</code></pre></div></div>

<p>We can use this to produce a sequence of the starting index for each group:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Array</span><span class="p">(</span><span class="nf">stride</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="nv">by</span><span class="p">:</span> <span class="mi">3</span><span class="p">))</span>
<span class="err">$</span><span class="kt">R</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="n">values</span> <span class="p">{</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this we can map over this sequence, and take a slice from the Array <code class="language-plaintext highlighter-rouge">self</code> (since we’re in an extension of <code class="language-plaintext highlighter-rouge">Array</code>) and convert it to a standalone array for convenience in a few minutes with something like the following:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Array</span><span class="p">(</span><span class="k">self</span><span class="p">[</span><span class="nv">$0</span> <span class="o">..&lt;</span> <span class="p">(</span><span class="nv">$0</span> <span class="o">+</span> <span class="n">size</span><span class="p">)])</span>
</code></pre></div></div>

<p>Leaving us with the final following implementation:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Array</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">chunked</span><span class="p">(</span><span class="n">into</span> <span class="nv">size</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Element</span><span class="p">]]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">stride</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span> <span class="nv">by</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span>
            <span class="kt">Array</span><span class="p">(</span><span class="k">self</span><span class="p">[</span><span class="nv">$0</span> <span class="o">..&lt;</span> <span class="nv">$0</span> <span class="o">+</span> <span class="n">size</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It should be noted that this method will fail with an out-of-bounds error for arrays that are not nicely groupable, so an extra bit of safety would either be to implement that as a check and throw an error if count is not cleanly divisible by 3 or to use something like <code class="language-plaintext highlighter-rouge">min($0 + size, count)</code> to cut the last group into a smaller slice without failing.</p>

<p>With this in place, we can finish up our task as we can now group the elves into sets of 3. We’ll reduce each group, calling <code class="language-plaintext highlighter-rouge">Set#intersection</code> to compute the final intersection of the group to determine what they’ve gotten duplicated amongst themselves. After that, we’ll return to our first solution and map each item to the priority number and finally sum it all together:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rucksacks</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">compartmentA</span><span class="o">.</span><span class="nf">union</span><span class="p">(</span><span class="nv">$0</span><span class="o">.</span><span class="n">compartmentB</span><span class="p">)</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">chunked</span><span class="p">(</span><span class="nv">into</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">chunk</span> <span class="k">in</span>
        <span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="o">..&lt;</span><span class="n">chunk</span><span class="o">.</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{</span> <span class="n">innerMemo</span><span class="p">,</span> <span class="n">prioritySet</span> <span class="k">in</span>
            <span class="n">innerMemo</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">prioritySet</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="n">first</span><span class="o">!</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="n">remapCharToPriority</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>We’re using a reduce here so that our code is a little more configurable and maintainable, but it boils down to something like:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">chunk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div></div>

<p>And with that our second star is within reach!</p>

<hr />

<ul>
  <li>
    <p><a href="/aoc/2022/12/01/aoc-2022.html">2022 Day Index</a></p>
  </li>
  <li>
    <p>Next: <a href="/aoc/2022/12/04/AoC-2022-Day-04.html">Day 04</a></p>
  </li>
  <li>
    <p>Previous: <a href="/aoc/2022/12/02/AoC-2022-Day-02.html">Day 02</a></p>
  </li>
</ul>


</article>

    </main>
  </div>

  <footer class="border-t-2 border-sky-900 my-4 pt-4 text-sm w-full flex justify-center">
    <p class="prose text-xs dark:prose-invert mx-4">
      Found an error or have an improvement?
      <a href="https://github.com/JoshAshby/joshashby.github.io/tree/source/_posts/2022-12-03-AoC-2022-Day-03.md">Suggest a correction!</a> | <span class="text-gray-300 text-xs">© Joshua Ashby</span>
    </p>
  </footer>

  
  <script src="/vite/assets/application.2826b514.js" crossorigin="anonymous" type="module"></script>


</body>
</html>
